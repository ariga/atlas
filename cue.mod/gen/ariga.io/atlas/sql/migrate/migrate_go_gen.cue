// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go ariga.io/atlas/sql/migrate

package migrate

import (
	"ariga.io/atlas/sql/schema"
	"time"
)

#Plan: {
	// Version and Name of the plan. Provided by the user or auto-generated.
	Version: string

	// Version and Name of the plan. Provided by the user or auto-generated.
	Name: string

	// Reversible describes if the changeset is reversible.
	Reversible: bool

	// Transactional describes if the changeset is transactional.
	Transactional: bool

	// Changes defines the list of changeset in the plan.
	Changes: [...null | #Change] @go(,[]*Change)
}

#Change: {
	// Cmd or statement to execute.
	Cmd: string

	// Args for placeholder parameters in the statement above.
	Args: [...] @go(,[]any)

	// A Comment describes the change.
	Comment: string

	// Reverse contains the "reversed statement" if
	// command is reversible.
	Reverse: string

	// The Source that caused this change, or nil.
	Source: schema.#Change
}

#Driver: _

#PlanApplier: _

#PlanOptions: {
	// PlanWithSchemaQualifier allows setting a custom schema to prefix
	// tables and other resources. An empty string indicates no qualifier.
	SchemaQualifier?: null | string @go(,*string)
}

#StateReader: _

#RevisionReadWriter: _

#Revision: {
	Version:         string
	Description:     string
	Type:            #RevisionType
	Applied:         int
	Total:           int
	ExecutedAt:      time.Time
	ExecutionTime:   time.#Duration
	Error?:          string
	ErrorStmt?:      string
	OperatorVersion: string
}

#RevisionType: string // #enumRevisionType

#enumRevisionType:
	#RevisionTypeUnknown |
	#RevisionTypeBaseline |
	#RevisionTypeExecute |
	#RevisionTypeResolved

#values_RevisionType: {
	RevisionTypeUnknown:  #RevisionTypeUnknown
	RevisionTypeBaseline: #RevisionTypeBaseline
	RevisionTypeExecute:  #RevisionTypeExecute
	RevisionTypeResolved: #RevisionTypeResolved
}

// RevisionTypeUnknown represents an unknown revision type.
// This type is unexpected and exists here to only ensure
// the type is not set to the zero value.
#RevisionTypeUnknown: #RevisionType & 0

// RevisionTypeBaseline represents a baseline revision. Note that only
// the first record can represent a baseline migration and most of its
// fields are set to the zero value.
#RevisionTypeBaseline: #RevisionType & 1

// RevisionTypeExecute represents a migration that was executed.
#RevisionTypeExecute: #RevisionType & 2

// RevisionTypeResolved represents a migration that was resolved. A migration
// script that was script executed and then resolved should set its Type to
// RevisionTypeExecute | RevisionTypeResolved.
#RevisionTypeResolved: #RevisionType & 4

// MissingMigrationError is returned if a revision is partially applied but
// the matching migration file is not found in the migration directory.
#MissingMigrationError: {
	Version:     string
	Description: string
}

// HistoryChangedError is returned if between two execution attempts already applied statements of a file have changed.
#HistoryChangedError: {
	File: string
	Stmt: int
}

#Snapshoter: _

#TableIdent: {
	Name:   string
	Schema: string
}

#CleanChecker: _

#NotCleanError: Reason: string

// NopRevisionReadWriter is a RevisionReadWriter that does nothing.
// It is useful for one-time replay of the migration directory.
#NopRevisionReadWriter: {
}

#Logger: _

#LogEntry: _

#LogExecution: {
	// From what version.
	From: string

	// To what version.
	To: string

	// Migration Files to be executed.
	Files: [...#File] @go(,[]File)
}

#LogFile: {
	// The File being executed.
	File: #File

	// Version executed.
	// Deprecated: Use File.Version() instead.
	Version: string

	// Desc of migration executed.
	// Deprecated: Use File.Desc() instead.
	Desc: string

	// Skip holds the number of stmts of this file that will be skipped.
	// This happens, if a migration file was only applied partially and will now continue to be applied.
	Skip: int
}

#LogStmt: SQL: string

#LogDone: {
}

#LogError: {
	SQL:   string
	Error: _ @go(,error)
}

#NopLogger: {
}

// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go ariga.io/atlas/sql/postgres

package postgres

import "ariga.io/atlas/sql/schema"

#CType: {
	Attr: schema.#Attr
	V:    string
}

#UserDefinedType: {
	Type: schema.#Type
	T:    string
}

_#enumType: {
	Type:   schema.#Type
	T:      string
	Schema: string
	ID:     int64
	Values: [...string] @go(,[]string)
}

#ArrayType: {
	Type: schema.#Type
	T:    string
}

#BitType: {
	Type: schema.#Type
	T:    string
	Len:  int64
}

#IntervalType: {
	Type:       schema.#Type
	T:          string
	F:          string
	Precision?: null | int @go(,*int)
}

#NetworkType: {
	Type: schema.#Type
	T:    string
	Len:  int64
}

#CurrencyType: {
	Type: schema.#Type
	T:    string
}

#SerialType: {
	Type:      schema.#Type
	T:         string
	Precision: int

	// SequenceName holds the inspected sequence name attached to the column.
	// It defaults to <Table>_<Column>_seq when the column is created, but may
	// be different in case the table or the column was renamed.
	SequenceName: string
}

#TextSearchType: {
	Type: schema.#Type
	T:    string
}

#UUIDType: {
	Type: schema.#Type
	T:    string
}

#XMLType: {
	Type: schema.#Type
	T:    string
}

#ConType: {
	Attr: schema.#Attr
	T:    string
}

#Sequence: {
	Start:     int64
	Increment: int64

	// Last sequence value written to disk.
	// https://postgresql.org/docs/current/view-pg-sequences.html.
	Last: int64
}

#Identity: {
	Attr:       schema.#Attr
	Generation: string
	Sequence?:  null | #Sequence @go(,*Sequence)
}

#IndexType: {
	Attr: schema.#Attr
	T:    string
}

#IndexPredicate: {
	Attr: schema.#Attr
	P:    string
}

#IndexColumnProperty: {
	Attr: schema.#Attr

	// NullsFirst defaults to true for DESC indexes.
	NullsFirst: bool

	// NullsLast defaults to true for ASC indexes.
	NullsLast: bool
}

#IndexStorageParams: {
	Attr: schema.#Attr

	// AutoSummarize defines the authsummarize storage parameter.
	AutoSummarize: bool

	// PagesPerRange defines pages_per_range storage
	// parameter for BRIN indexes. Defaults to 128.
	PagesPerRange: int64
}

#IndexInclude: {
	Attr: schema.#Attr
	Columns: [...null | schema.#Column] @go(,[]*schema.Column)
}

#IndexOpClass: string

#Concurrently: Attr: schema.#Attr

#NoInherit: Attr: schema.#Attr

#CheckColumns: {
	Attr: schema.#Attr
	Columns: [...string] @go(,[]string)
}

#Partition: {
	Attr: schema.#Attr

	// T defines the type/strategy of the partition.
	// Can be one of: RANGE, LIST, HASH.
	T: string

	// Partition parts. The additional attributes
	// on each part can be used to control collation.
	Parts: [...null | #PartitionPart] @go(,[]*PartitionPart)
}

#PartitionPart: {
	X:  schema.#Expr
	C?: null | schema.#Column @go(,*schema.Column)
	Attrs: [...schema.#Attr] @go(,[]schema.Attr)
}

// Query to list runtime parameters.
_#paramsQuery: "SELECT setting FROM pg_settings WHERE name IN ('lc_collate', 'lc_ctype', 'server_version_num', 'crdb_version') ORDER BY name DESC" // `SELECT setting FROM pg_settings WHERE name IN ('lc_collate',
		// 'lc_ctype', 'server_version_num', 'crdb_version') ORDER BY
		// name DESC`

// Query to list database schemas.
_#schemasQuery: "SELECT schema_name FROM information_schema.schemata WHERE schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast', 'crdb_internal', 'pg_extension') AND schema_name NOT LIKE 'pg_%temp_%' ORDER BY schema_name"

// Query to list specific database schemas.
_#schemasQueryArgs: "SELECT schema_name FROM information_schema.schemata WHERE schema_name %s ORDER BY schema_name"

// Query to list table information.
_#tablesQuery:     "\nSELECT\n\tt1.table_schema,\n\tt1.table_name,\n\tpg_catalog.obj_description(t3.oid, 'pg_class') AS comment,\n\tt4.partattrs AS partition_attrs,\n\tt4.partstrat AS partition_strategy,\n\tpg_get_expr(t4.partexprs, t4.partrelid) AS partition_exprs\nFROM\n\tINFORMATION_SCHEMA.TABLES AS t1\n\tJOIN pg_catalog.pg_namespace AS t2 ON t2.nspname = t1.table_schema\n\tJOIN pg_catalog.pg_class AS t3 ON t3.relnamespace = t2.oid AND t3.relname = t1.table_name\n\tLEFT JOIN pg_catalog.pg_partitioned_table AS t4 ON t4.partrelid = t3.oid\nWHERE\n\tt1.table_type = 'BASE TABLE'\n\tAND NOT COALESCE(t3.relispartition, false)\n\tAND t1.table_schema IN (%s)\nORDER BY\n\tt1.table_schema, t1.table_name\n" // `
			// SELECT
			// t1.table_schema,
			// t1.table_name,
			// pg_catalog.obj_description(t3.oid, 'pg_class') AS comment,
			// t4.partattrs AS partition_attrs,
			// t4.partstrat AS partition_strategy,
			// pg_get_expr(t4.partexprs, t4.partrelid) AS partition_exprs
			// FROM
			// INFORMATION_SCHEMA.TABLES AS t1
			// JOIN pg_catalog.pg_namespace AS t2 ON t2.nspname =
			// t1.table_schema
			// JOIN pg_catalog.pg_class AS t3 ON t3.relnamespace = t2.oid AND
			// t3.relname = t1.table_name
			// LEFT JOIN pg_catalog.pg_partitioned_table AS t4 ON t4.partrelid
			// = t3.oid
			// WHERE
			// t1.table_type = 'BASE TABLE'
			// AND NOT COALESCE(t3.relispartition, false)
			// AND t1.table_schema IN (%s)
			// ORDER BY
			// t1.table_schema, t1.table_name
			// `
_#tablesQueryArgs: "\nSELECT\n\tt1.table_schema,\n\tt1.table_name,\n\tpg_catalog.obj_description(t3.oid, 'pg_class') AS comment,\n\tt4.partattrs AS partition_attrs,\n\tt4.partstrat AS partition_strategy,\n\tpg_get_expr(t4.partexprs, t4.partrelid) AS partition_exprs\nFROM\n\tINFORMATION_SCHEMA.TABLES AS t1\n\tJOIN pg_catalog.pg_namespace AS t2 ON t2.nspname = t1.table_schema\n\tJOIN pg_catalog.pg_class AS t3 ON t3.relnamespace = t2.oid AND t3.relname = t1.table_name\n\tLEFT JOIN pg_catalog.pg_partitioned_table AS t4 ON t4.partrelid = t3.oid\nWHERE\n\tt1.table_type = 'BASE TABLE'\n\tAND NOT COALESCE(t3.relispartition, false)\n\tAND t1.table_schema IN (%s)\n\tAND t1.table_name IN (%s)\nORDER BY\n\tt1.table_schema, t1.table_name\n" // `
			// SELECT
			// t1.table_schema,
			// t1.table_name,
			// pg_catalog.obj_description(t3.oid, 'pg_class') AS comment,
			// t4.partattrs AS partition_attrs,
			// t4.partstrat AS partition_strategy,
			// pg_get_expr(t4.partexprs, t4.partrelid) AS partition_exprs
			// FROM
			// INFORMATION_SCHEMA.TABLES AS t1
			// JOIN pg_catalog.pg_namespace AS t2 ON t2.nspname =
			// t1.table_schema
			// JOIN pg_catalog.pg_class AS t3 ON t3.relnamespace = t2.oid AND
			// t3.relname = t1.table_name
			// LEFT JOIN pg_catalog.pg_partitioned_table AS t4 ON t4.partrelid
			// = t3.oid
			// WHERE
			// t1.table_type = 'BASE TABLE'
			// AND NOT COALESCE(t3.relispartition, false)
			// AND t1.table_schema IN (%s)
			// AND t1.table_name IN (%s)
			// ORDER BY
			// t1.table_schema, t1.table_name
			// `

// Query to list table columns.
_#columnsQuery: "\nSELECT\n\tt1.table_name,\n\tt1.column_name,\n\tt1.data_type,\n\tpg_catalog.format_type(a.atttypid, a.atttypmod) AS format_type,\n\tt1.is_nullable,\n\tt1.column_default,\n\tt1.character_maximum_length,\n\tt1.numeric_precision,\n\tt1.datetime_precision,\n\tt1.numeric_scale,\n\tt1.interval_type,\n\tt1.character_set_name,\n\tt1.collation_name,\n\tt1.is_identity,\n\tt1.identity_start,\n\tt1.identity_increment,\n\t(CASE WHEN t1.is_identity = 'YES' THEN (SELECT last_value FROM pg_sequences WHERE quote_ident(schemaname) || '.' || quote_ident(sequencename) = pg_get_serial_sequence(quote_ident(t1.table_schema) || '.' || quote_ident(t1.table_name), t1.column_name)) END) AS identity_last,\n\tt1.identity_generation,\n\tt1.generation_expression,\n\tcol_description(t3.oid, \"ordinal_position\") AS comment,\n\tt4.typtype,\n\tt4.typelem,\n\t(CASE WHEN t4.typcategory = 'A' AND t4.typelem <> 0 THEN (SELECT t.typtype FROM pg_catalog.pg_type t WHERE t.oid = t4.typelem) END) AS elemtyp,\n\tt4.oid\nFROM\n\t\"information_schema\".\"columns\" AS t1\n\tJOIN pg_catalog.pg_namespace AS t2 ON t2.nspname = t1.table_schema\n\tJOIN pg_catalog.pg_class AS t3 ON t3.relnamespace = t2.oid AND t3.relname = t1.table_name\n\tJOIN pg_catalog.pg_attribute AS a ON a.attrelid = t3.oid AND a.attname = t1.column_name\n\tLEFT JOIN pg_catalog.pg_type AS t4 ON t4.oid = a.atttypid\nWHERE\n\tt1.table_schema = $1 AND t1.table_name IN (%s)\nORDER BY\n\tt1.table_name, t1.ordinal_position\n" // `
		// SELECT
		// t1.table_name,
		// t1.column_name,
		// t1.data_type,
		// pg_catalog.format_type(a.atttypid, a.atttypmod) AS format_type,
		// t1.is_nullable,
		// t1.column_default,
		// t1.character_maximum_length,
		// t1.numeric_precision,
		// t1.datetime_precision,
		// t1.numeric_scale,
		// t1.interval_type,
		// t1.character_set_name,
		// t1.collation_name,
		// t1.is_identity,
		// t1.identity_start,
		// t1.identity_increment,
		// (CASE WHEN t1.is_identity = 'YES' THEN (SELECT last_value FROM
		// pg_sequences WHERE quote_ident(schemaname) || '.' ||
		// quote_ident(sequencename) =
		// pg_get_serial_sequence(quote_ident(t1.table_schema) || '.' ||
		// quote_ident(t1.table_name), t1.column_name)) END) AS
		// identity_last,
		// t1.identity_generation,
		// t1.generation_expression,
		// col_description(t3.oid, "ordinal_position") AS comment,
		// t4.typtype,
		// t4.typelem,
		// (CASE WHEN t4.typcategory = 'A' AND t4.typelem <> 0 THEN
		// (SELECT t.typtype FROM pg_catalog.pg_type t WHERE t.oid =
		// t4.typelem) END) AS elemtyp,
		// t4.oid
		// FROM
		// "information_schema"."columns" AS t1
		// JOIN pg_catalog.pg_namespace AS t2 ON t2.nspname =
		// t1.table_schema
		// JOIN pg_catalog.pg_class AS t3 ON t3.relnamespace = t2.oid AND
		// t3.relname = t1.table_name
		// JOIN pg_catalog.pg_attribute AS a ON a.attrelid = t3.oid AND
		// a.attname = t1.column_name
		// LEFT JOIN pg_catalog.pg_type AS t4 ON t4.oid = a.atttypid
		// WHERE
		// t1.table_schema = $1 AND t1.table_name IN (%s)
		// ORDER BY
		// t1.table_name, t1.ordinal_position
		// `
_#fksQuery:     "\nSELECT\n    t1.constraint_name,\n    t1.table_name,\n    t2.column_name,\n    t1.table_schema,\n    t3.table_name AS referenced_table_name,\n    t3.column_name AS referenced_column_name,\n    t3.table_schema AS referenced_schema_name,\n    t4.update_rule,\n    t4.delete_rule\nFROM\n    information_schema.table_constraints t1\n    JOIN information_schema.key_column_usage t2\n    ON t1.constraint_name = t2.constraint_name\n    AND t1.table_schema = t2.constraint_schema\n    JOIN information_schema.constraint_column_usage t3\n    ON t1.constraint_name = t3.constraint_name\n    AND t1.table_schema = t3.constraint_schema\n    JOIN information_schema.referential_constraints t4\n    ON t1.constraint_name = t4.constraint_name\n    AND t1.table_schema = t4.constraint_schema\nWHERE\n    t1.constraint_type = 'FOREIGN KEY'\n    AND t1.table_schema = $1\n    AND t1.table_name IN (%s)\nORDER BY\n    t1.constraint_name,\n    t2.ordinal_position\n" // `
		// SELECT
		// t1.constraint_name,
		// t1.table_name,
		// t2.column_name,
		// t1.table_schema,
		// t3.table_name AS referenced_table_name,
		// t3.column_name AS referenced_column_name,
		// t3.table_schema AS referenced_schema_name,
		// t4.update_rule,
		// t4.delete_rule
		// FROM
		// information_schema.table_constraints t1
		// JOIN information_schema.key_column_usage t2
		// ON t1.constraint_name = t2.constraint_name
		// AND t1.table_schema = t2.constraint_schema
		// JOIN information_schema.constraint_column_usage t3
		// ON t1.constraint_name = t3.constraint_name
		// AND t1.table_schema = t3.constraint_schema
		// JOIN information_schema.referential_constraints t4
		// ON t1.constraint_name = t4.constraint_name
		// AND t1.table_schema = t4.constraint_schema
		// WHERE
		// t1.constraint_type = 'FOREIGN KEY'
		// AND t1.table_schema = $1
		// AND t1.table_name IN (%s)
		// ORDER BY
		// t1.constraint_name,
		// t2.ordinal_position
		// `

// Query to list table check constraints.
_#checksQuery: "\nSELECT\n\trel.relname AS table_name,\n\tt1.conname AS constraint_name,\n\tpg_get_expr(t1.conbin, t1.conrelid) as expression,\n\tt2.attname as column_name,\n\tt1.conkey as column_indexes,\n\tt1.connoinherit as no_inherit\nFROM\n\tpg_constraint t1\n\tJOIN pg_attribute t2\n\tON t2.attrelid = t1.conrelid\n\tAND t2.attnum = ANY (t1.conkey)\n\tJOIN pg_class rel\n\tON rel.oid = t1.conrelid\n\tJOIN pg_namespace nsp\n\tON nsp.oid = t1.connamespace\nWHERE\n\tt1.contype = 'c'\n\tAND nsp.nspname = $1\n\tAND rel.relname IN (%s)\nORDER BY\n\tt1.conname, array_position(t1.conkey, t2.attnum)\n" // `
		// SELECT
		// rel.relname AS table_name,
		// t1.conname AS constraint_name,
		// pg_get_expr(t1.conbin, t1.conrelid) as expression,
		// t2.attname as column_name,
		// t1.conkey as column_indexes,
		// t1.connoinherit as no_inherit
		// FROM
		// pg_constraint t1
		// JOIN pg_attribute t2
		// ON t2.attrelid = t1.conrelid
		// AND t2.attnum = ANY (t1.conkey)
		// JOIN pg_class rel
		// ON rel.oid = t1.conrelid
		// JOIN pg_namespace nsp
		// ON nsp.oid = t1.connamespace
		// WHERE
		// t1.contype = 'c'
		// AND nsp.nspname = $1
		// AND rel.relname IN (%s)
		// ORDER BY
		// t1.conname, array_position(t1.conkey, t2.attnum)
		// `

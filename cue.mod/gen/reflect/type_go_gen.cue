// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go reflect

// Package reflect implements run-time reflection, allowing a program to
// manipulate objects with arbitrary types. The typical use is to take a value
// with static type interface{} and extract its dynamic type information by
// calling TypeOf, which returns a Type.
//
// A call to ValueOf returns a Value representing the run-time data.
// Zero takes a Type and returns a Value representing a zero value
// for that type.
//
// See "The Laws of Reflection" for an introduction to reflection in Go:
// https://golang.org/doc/articles/laws_of_reflection.html
package reflect

// Type is the representation of a Go type.
//
// Not all methods apply to all kinds of types. Restrictions,
// if any, are noted in the documentation for each method.
// Use the Kind method to find out the kind of type before
// calling kind-specific methods. Calling a method
// inappropriate to the kind of type causes a run-time panic.
//
// Type values are comparable, such as with the == operator,
// so they can be used as map keys.
// Two Type values are equal if they represent identical types.
#Type: _

// A Kind represents the specific kind of type that a Type represents.
// The zero Kind is not a valid kind.
#Kind: uint // #enumKind

#enumKind:
	#Invalid |
	#Bool |
	#Int |
	#Int8 |
	#Int16 |
	#Int32 |
	#Int64 |
	#Uint |
	#Uint8 |
	#Uint16 |
	#Uint32 |
	#Uint64 |
	#Uintptr |
	#Float32 |
	#Float64 |
	#Complex64 |
	#Complex128 |
	#Array |
	#Chan |
	#Func |
	#Interface |
	#Map |
	#Pointer |
	#Slice |
	#String |
	#Struct |
	#UnsafePointer |
	#Ptr

#values_Kind: {
	Invalid:       #Invalid
	Bool:          #Bool
	Int:           #Int
	Int8:          #Int8
	Int16:         #Int16
	Int32:         #Int32
	Int64:         #Int64
	Uint:          #Uint
	Uint8:         #Uint8
	Uint16:        #Uint16
	Uint32:        #Uint32
	Uint64:        #Uint64
	Uintptr:       #Uintptr
	Float32:       #Float32
	Float64:       #Float64
	Complex64:     #Complex64
	Complex128:    #Complex128
	Array:         #Array
	Chan:          #Chan
	Func:          #Func
	Interface:     #Interface
	Map:           #Map
	Pointer:       #Pointer
	Slice:         #Slice
	String:        #String
	Struct:        #Struct
	UnsafePointer: #UnsafePointer
	Ptr:           #Ptr
}

#Invalid:       #Kind & 0
#Bool:          #Kind & 1
#Int:           #Kind & 2
#Int8:          #Kind & 3
#Int16:         #Kind & 4
#Int32:         #Kind & 5
#Int64:         #Kind & 6
#Uint:          #Kind & 7
#Uint8:         #Kind & 8
#Uint16:        #Kind & 9
#Uint32:        #Kind & 10
#Uint64:        #Kind & 11
#Uintptr:       #Kind & 12
#Float32:       #Kind & 13
#Float64:       #Kind & 14
#Complex64:     #Kind & 15
#Complex128:    #Kind & 16
#Array:         #Kind & 17
#Chan:          #Kind & 18
#Func:          #Kind & 19
#Interface:     #Kind & 20
#Map:           #Kind & 21
#Pointer:       #Kind & 22
#Slice:         #Kind & 23
#String:        #Kind & 24
#Struct:        #Kind & 25
#UnsafePointer: #Kind & 26

#Ptr: #Kind & 22

// tflag is used by an rtype to signal what extra type information is
// available in the memory directly following the rtype value.
//
// tflag values must be kept in sync with copies in:
//
//       cmd/compile/internal/reflectdata/reflect.go
//       cmd/link/internal/ld/decodesym.go
//       runtime/type.go
_#tflag: uint8

// tflagUncommon means that there is a pointer, *uncommonType,
// just beyond the outer type structure.
//
// For example, if t.Kind() == Struct and t.tflag&tflagUncommon != 0,
// then t has uncommonType data and it can be accessed as:
//
//               type tUncommon struct {
//                structType
//                u uncommonType
//               }
//               u := &(*tUncommon)(unsafe.Pointer(t)).u
_#tflagUncommon: _#tflag & 1

// tflagExtraStar means the name in the str field has an
// extraneous '*' prefix. This is because for most types T in
// a program, the type *T also exists and reusing the str data
// saves binary size.
_#tflagExtraStar: _#tflag & 2

// tflagNamed means the type has a name.
_#tflagNamed: _#tflag & 4

// tflagRegularMemory means that equal and hash functions can treat
// this type as a single region of t.size bytes.
_#tflagRegularMemory: _#tflag & 8

// ChanDir represents a channel type's direction.
#ChanDir: int // #enumChanDir

#enumChanDir:
	#RecvDir |
	#SendDir |
	#BothDir

#values_ChanDir: {
	RecvDir: #RecvDir
	SendDir: #SendDir
	BothDir: #BothDir
}

#RecvDir: #ChanDir & 1
#SendDir: #ChanDir & 2
#BothDir: #ChanDir & 3

// Method represents a single method.
#Method: {
	// Name is the method name.
	Name: string

	// PkgPath is the package path that qualifies a lower case (unexported)
	// method name. It is empty for upper case (exported) method names.
	// The combination of PkgPath and Name uniquely identifies a method
	// in a method set.
	// See https://golang.org/ref/spec#Uniqueness_of_identifiers
	PkgPath: string
	Type:    #Type
	Index:   int
}

_#kindDirectIface: 32
_#kindGCProg:      64
_#kindMask:        31

_#nameOff: int32

_#typeOff: int32

_#textOff: int32

// A StructField describes a single field in a struct.
#StructField: {
	// Name is the field name.
	Name: string

	// PkgPath is the package path that qualifies a lower case (unexported)
	// field name. It is empty for upper case (exported) field names.
	// See https://golang.org/ref/spec#Uniqueness_of_identifiers
	PkgPath: string
	Type:    #Type
	Tag:     #StructTag
	Offset:  uint64 @go(,uintptr)
	Index: [...int] @go(,[]int)
	Anonymous: bool
}

// A StructTag is the tag string in a struct field.
//
// By convention, tag strings are a concatenation of
// optionally space-separated key:"value" pairs.
// Each key is a non-empty string consisting of non-control
// characters other than space (U+0020 ' '), quote (U+0022 '"'),
// and colon (U+003A ':').  Each value is quoted using U+0022 '"'
// characters and Go string literal syntax.
#StructTag: string

_#bucketSize: uint64 & 8
_#maxKeySize: uint64 & 128
_#maxValSize: uint64 & 128

_#maxPtrmaskBytes: 2048

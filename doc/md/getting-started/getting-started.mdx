---
id: getting-started
title: Quick Introduction
sidebar_label: Quick Introduction
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Atlas CLI is an open-source tool designed to help software engineers, DBAs and DevOps
practitioners to manage their database schemas.  Atlas users can use the [Atlas DDL](../atlas-schema/sql-resources)
(data-definition language) to describe the desired database schema and use the command-line
tool to plan and apply the migrations to their systems.

### Installation

<Tabs
defaultValue="apple-intel-brew"
values={[
{label: 'macOS (Homebrew)', value: 'apple-intel-brew'},
{label: 'macOS (Plain)', value: 'apple-intel-plain'},
{label: 'Linux', value: 'linux'},
{label: 'Windows', value: 'windows'},
]}>
<TabItem value="apple-intel-brew">

Get the latest release with [Homebrew](https://brew.sh/):

```shell
brew install ariga/tap/atlas
```

</TabItem>
<TabItem value="apple-intel-plain">

Download latest release.
```shell
curl -LO https://release.ariga.io/atlas/atlas-darwin-amd64-latest
```

Make the atlas binary executable.
```shell
chmod +x ./atlas-darwin-amd64-latest
```

Move the atlas binary to a file location on your system PATH.
```shell
sudo mv ./atlas-darwin-amd64-latest /usr/local/bin/atlas
```
```shell
sudo chown root: /usr/local/bin/atlas
```

</TabItem>
<TabItem value="linux">

Download latest release.
```shell
curl -LO https://release.ariga.io/atlas/atlas-linux-amd64-latest
```

Move the atlas binary to a file location on your system PATH.
```shell
sudo install -o root -g root -m 0755 ./atlas-linux-amd64-latest /usr/local/bin/atlas
```

</TabItem>
<TabItem value="windows">

Download the [latest release](https://release.ariga.io/atlas/atlas-windows-amd64-latest.exe) and
move the atlas binary to a file location on your system PATH.


</TabItem>
</Tabs>

:::info
Latest release is updated twice a day and is based on the most recent tagged release.
:::

The binaries distributed in official releases are released under the  [Ariga End User License](https://ariga.io/legal/atlas/eula).
If you would like to build Atlas from source follow the instructions [here](https://atlasgo.io/cli-reference#building-from-source).

### Start a local database container

For the purpose of this guide, we will start a local Docker container running MySQL.

```shell
docker run --name atlas-db -p 3306:3306 -e MYSQL_ROOT_PASSWORD=pass -e MYSQL_DATABASE=example mysql
```

### Inspecting our database

Atlas features a Data Definition Language (DDL) that has an [HCL-syntax](https://github.com/hashicorp/hcl)
for defining the desired state of database schemas.

Inspection is done via the `atlas schema inspect` command. To learn about its parameters, run:
```shell
atlas schema inspect --help
```

To inspect our locally-running MySQL instance, use the `-u` flag and write output to a file named `schema.hcl`:

<Tabs
defaultValue="mysql"
values={[
{label: 'MySQL', value: 'mysql'},
{label: 'MariaDB', value: 'maria'},
{label: 'PostgreSQL', value: 'postgres'},
{label: 'SQLite', value: 'sqlite'},
]}>
<TabItem value="mysql">

```shell
atlas schema inspect -u "mysql://root:pass@localhost:3306/example" > schema.hcl
```

Then, view the contents of the file:

```hcl title="schema.hcl"
schema "example" {
  charset = "utf8mb4"
  collate = "utf8mb4_0900_ai_ci"
}
```

</TabItem>
<TabItem value="maria">

```shell
atlas schema inspect -u "maria://root:pass@localhost:3306/example" > schema.hcl
```

Then, view the contents of the file:

```hcl title="schema.hcl"
schema "example" {
  charset = "utf8mb4"
  collate = "utf8mb4_0900_ai_ci"
}
```

</TabItem>
<TabItem value="postgres">

```shell
atlas schema inspect -u "postgres://postgres:pass@localhost:5432/example?sslmode=disable" > schema.hcl
```

Then, view the contents of the file:

```hcl title="schema.hcl"
schema "public" {
}
```

</TabItem>
<TabItem value="sqlite">

```shell
atlas schema inspect -u "sqlite://file.db" > schema.hcl
```

Then, view the contents of the file:

```hcl title="schema.hcl"
schema "main" {
}
```

</TabItem>
</Tabs>

As you can see, Atlas inspected our (empty) database and wrote an Atlas HCL document
containing only a [Schema](../atlas-schema/sql.mdx#schema) resource.

### Modifying our database schema manually

In your database command-line prompt, create the tables:
```sql
CREATE table users (
    id int PRIMARY KEY,
    name varchar(100)
);
CREATE TABLE blog_posts (
    id int PRIMARY KEY,
    title varchar(100),
    body text,
    author_id int,
    FOREIGN KEY (author_id) REFERENCES users(id)
);
```
Observe that the tables are created successfully:
```text
Query OK, 0 rows affected (0.02 sec)
```
Our schema represents a highly simplified blogging system with a `users` table for the authors and a `blog_posts` table
for the contents:

![Blog ERD](https://atlasgo.io/uploads/images/blog-erd.png)

### Inspecting table schemas with Atlas

Next, let's re-run the inspection command:

<Tabs
defaultValue="mysql"
values={[
{label: 'MySQL', value: 'mysql'},
{label: 'MariaDB', value: 'maria'},
{label: 'PostgreSQL', value: 'postgres'},
{label: 'SQLite', value: 'sqlite'},
]}>
<TabItem value="mysql">

```shell
atlas schema inspect -u "mysql://root:pass@localhost:3306/example" > schema.hcl
```

</TabItem>
<TabItem value="maria">

```shell
atlas schema inspect -u "maria://root:pass@localhost:3306/example" > schema.hcl
```

</TabItem>
<TabItem value="postgres">

```shell
atlas schema inspect -u "postgres://postgres:pass@localhost:5432/example?sslmode=disable" > schema.hcl
```

</TabItem>
<TabItem value="sqlite">

```shell
atlas schema inspect -u "sqlite://file.db" > schema.hcl
```

</TabItem>
</Tabs>

Browse through the updated contents of the file, it contains 3 blocks representing
our schema as before, and two new blocks representing the `users` and `blog_posts` tables.
Consider the following block:
```hcl
table "users" {
  schema = schema.example
  column "id" {
    null = false
    type = int
  }
  column "name" {
    null = true
    type = varchar(100)
  }
  primary_key {
    columns = [column.id]
  }
}
```
This block represents a [Table](../atlas-schema/sql.mdx#table) resource with `id`, and `name`
columns. The `schema` field references the `example` schema that is defined elsewhere
in this document. In addition, the `primary_key` sub-block defines the `id` column as
the primary key for the table. In SQL databases, columns usually have a type attribute
that defines the kind of data that can be stored in that column. Atlas strives to
mimic the syntax of the database that the user is working against. In this case, the
type for the `id` column is `int`, and `varchar(100)` for the `name` column. To
see the full list of supported types, [click here](../atlas-schema/sql-types.md).

Next, consider this block:
```hcl
table "blog_posts" {
  schema = schema.example
  column "id" {
    null = false
    type = int
  }
  column "title" {
    null = true
    type = varchar(100)
  }
  column "body" {
    null = true
    type = text
  }
  column "author_id" {
    null = true
    type = int
  }
  primary_key {
    columns = [column.id]
  }
  foreign_key "blog_posts_ibfk_1" {
    columns     = [column.author_id]
    ref_columns = [table.users.column.id]
    on_update   = NO_ACTION
    on_delete   = NO_ACTION
  }
  index "author_id" {
    unique  = false
    columns = [column.author_id]
  }
}
```
This block represents the `blog_posts` table. In addition to the elements
we saw in the `users` table, here we can find a [Foreign Key](../atlas-schema/sql.mdx#foreign-key)
block, declaring that the `author_id` column references the `id` column on the
`users` table.

To learn more about the resource types that are available to describe SQL schemas,
read the [SQL Syntax](../atlas-schema/sql.mdx) documentation.

### Declarative migrations

To modify the database's schema we will use Atlas's `atlas schema apply` command which takes a _declarative_ approach,
that is, we define the _desired_ end schema, and Atlas figures out a safe-way to alter
the database to get there. Atlas offers an alternative workflow called _versioned migrations_,
where each change to the database schema is checked-in to source control and reviewed during code-review.
Read more about the use-cases two approaches [here](/concepts/declarative-vs-versioned).

Let's start by viewing the help text for the `apply` command:

```shell
atlas schema apply --help
```

You can see that similar to the `inspect` command, the `-u` flag is used to define the
URL to connect to the database, and an additional flag `-f` specifies the path to
the file containing the desired schema.

### Adding new tables to our database

Let's modify our simplified blogging platform schema from the previous step by adding
a third table, `categories`. Each table will have an `id` and a `name`. In addition,
we will create an association table `post_categories` which creates a many-to-many
relationship between blog posts and categories:

![Blog ERD](https://atlasgo.io/uploads/images/blog-erd-2.png)

First, let's store the existing schema in a file named `schema.hcl`:

<Tabs
defaultValue="mysql"
values={[
{label: 'MySQL', value: 'mysql'},
{label: 'MariaDB', value: 'maria'},
{label: 'PostgreSQL', value: 'postgres'},
{label: 'SQLite', value: 'sqlite'},
]}>
<TabItem value="mysql">

```shell
atlas schema inspect -u "mysql://root:pass@localhost:3306/example" > schema.hcl
```

</TabItem>
<TabItem value="maria">

```shell
atlas schema inspect -u "maria://root:pass@localhost:3306/example" > schema.hcl
```

</TabItem>
<TabItem value="postgres">

```shell
atlas schema inspect -u "postgres://postgres:pass@localhost:5432/example?sslmode=disable" > schema.hcl
```

</TabItem>
<TabItem value="sqlite">

```shell
atlas schema inspect -u "sqlite://file.db" > schema.hcl
```

</TabItem>
</Tabs>

Next, add the following table definition to the file:
```hcl
table "categories" {
  schema = schema.example
  column "id" {
    null = false
    type = int
  }
  column "name" {
    null = true
    type = varchar(100)
  }
  primary_key {
    columns = [column.id]
  }
}
```

To add this table to our database, let's use the `atlas schema apply` command:


<Tabs
defaultValue="mysql"
values={[
{label: 'MySQL', value: 'mysql'},
{label: 'MariaDB', value: 'maria'},
{label: 'PostgreSQL', value: 'postgres'},
{label: 'SQLite', value: 'sqlite'},
]}>
<TabItem value="mysql">

```shell
atlas schema apply -u "mysql://root:pass@localhost:3306/example" -f schema.hcl
```

</TabItem>
<TabItem value="maria">

```shell
atlas schema apply -u "maria://root:pass@localhost:3306/example" -f schema.hcl
```

</TabItem>
<TabItem value="postgres">

```shell
atlas schema apply -u "postgres://postgres:pass@localhost:5432/example?sslmode=disable" -f schema.hcl
```

</TabItem>
<TabItem value="sqlite">

```shell
atlas schema apply -u "sqlite://file.db" -f schema.hcl
```

</TabItem>
</Tabs>

Atlas plans a migration (schema change) for us and prompts us to approve it:
```text
-- Planned Changes:
-- Create "categories" table
CREATE TABLE `example`.`categories` (`id` int NOT NULL, `name` varchar(100) NULL, PRIMARY KEY (`id`))
Use the arrow keys to navigate: ↓ ↑ → ←
? Are you sure?:
  ▸ Apply
    Abort
```
To apply the migration, press `ENTER`, and voila!
```text
✔ Apply
```

To verify that our new table was created, open the database command line tool from previous step and run:

```text
mysql> show create table categories;
+------------+------------------------------------------------------+
| Table      | Create Table                                                                                                                                                                 |
+------------+------------------------------------------------------+
| categories | CREATE TABLE `categories` (
  `id` int NOT NULL,
  `name` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
+------------+------------------------------------------------------
1 row in set (0.01 sec)
```

Amazing! Our new table was created. Next, let's define our association table,
add the following block to our `schema.hcl` file:
```hcl
table "post_categories" {
    schema = schema.example
    column "post_id" {
        type = int
    }
    column "category_id" {
        type = int
    }
    foreign_key "post_category_post" {
        columns     = [column.post_id]
        ref_columns = [table.blog_posts.column.id]
    }
    foreign_key "post_category_category" {
        columns     = [column.category_id]
        ref_columns = [table.categories.column.id]
    }
}
```
This block defines the `post_categories` table with two columns `post_id` and `category_id`.
In addition, two foreign-keys are created referencing the respective columns on the `blog_posts`
and `categories` tables.

Apply the schema again, this time with the updated schema:

<Tabs
defaultValue="mysql"
values={[
{label: 'MySQL', value: 'mysql'},
{label: 'MariaDB', value: 'maria'},
{label: 'PostgreSQL', value: 'postgres'},
{label: 'SQLite', value: 'sqlite'},
]}>
<TabItem value="mysql">

```shell
atlas schema apply -u "mysql://root:pass@localhost:3306/example" -f schema.hcl
```

</TabItem>
<TabItem value="maria">

```shell
atlas schema apply -u "maria://root:pass@localhost:3306/example" -f schema.hcl
```

</TabItem>
<TabItem value="postgres">

```shell
atlas schema apply -u "postgres://postgres:pass@localhost:5432/example?sslmode=disable" -f schema.hcl
```

</TabItem>
<TabItem value="sqlite">

```shell
atlas schema apply -u "sqlite://file.db" -f schema.hcl
```

</TabItem>
</Tabs>

Atlas should show you the following plan:

```text
-- Planned Changes:
-- Create "post_categories" table
CREATE TABLE `example`.`post_categories` (`post_id` int NOT NULL, `category_id` int NOT NULL, CONSTRAINT `post_category_post` FOREIGN KEY (`post_id`) REFERENCES `example`.`blog_posts` (`id`), CONSTRAINT `post_category_category` FOREIGN KEY (`category_id`) REFERENCES `example`.`categories` (`id`))
✔ Apply
```





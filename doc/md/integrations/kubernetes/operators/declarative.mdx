---
title: Kubernetes Operator - Declarative Workflow
id: declarative
slug: /integrations/kubernetes/operators/declarative
---

import Credentials from './credentials.mdx';

### Installation

The Atlas Kubernetes Operator is available as a Helm Chart. To install the chart with the release name `atlas-operator`:

```bash
helm install atlas-operator oci://ghcr.io/ariga/charts/atlas-operator
```

### Credentials
<Credentials/>

### Defining the desired schema

The Atlas Operator relies on a Kubernetes custom resource called `AtlasSchema` to define the desired schema of your database.
You can find the full definition for this resource on the [ariga/atlas-operator repo](https://github.com/ariga/atlas-operator/blob/master/charts/atlas-operator/templates/crds/crd.yaml).
This resource describes the desired state of a target database that is used in the operator's reconciliation loop.

Let's review an example of such as a resource. Create a file named `atlas-schema.yaml` with the following contents:

```yaml title="atlas-schema.yaml"
apiVersion: db.atlasgo.io/v1alpha1
kind: AtlasSchema
metadata:
  name: myapp
spec:
  # Load the URL of the target database from a Kubernetes secret.
  urlFrom:
    secretKeyRef:
      key: url
      name: mysql-credentials
  # Define the desired schema of the target database. This can be defined in either
  # plain SQL like this example or in Atlas HCL.
  schema:
    sql: |
      create table users (
        id int not null auto_increment,
        name varchar(255) not null,
        email varchar(255) unique not null,
        short_bio varchar(255) not null,
        primary key (id)
      );
  # Define policies that control how the operator will apply changes to the target database.
  policy:
    # Define a policy that will stop the reconciliation loop if the operator detects
    # a destructive change such as dropping a column or table.
    lint:
      destructive:
        error: true
    # Define a policy that omits DROP COLUMN changes from any produced plan.
    diff:
      skip:
        drop_column: true
  # Exclude a table from being managed by the operator. This is useful for resources
  # that belong to other applications and are managed in other ways.
  exclude:
    - external_table_managed_elsewhere
```

Apply this file to your cluster:
```
kubectl apply -f atlas-schema.yaml
```

Wait for the operator to reconcile the desired state with the actual state of the database:

```
kubectl wait --for=condition=Ready atlasschema/myapp --timeout=60s
```

Alternatively, you can use a `ConfigMap` to store the desired schema of your database. To use
this approach, create a ConfigMap with the desired schema:

```yaml title="atlas-schema-configmap.yaml"
kind: ConfigMap
apiVersion: v1
metadata:
  name: mysql-schema
data:
  schema.sql: |
    create table users (
       id int not null auto_increment,
       name varchar(255) not null,
       email varchar(255) unique not null,
       short_bio varchar(255) not null,
       primary key (id)
    );
```

Then, update the `AtlasSchema` resource to reference the config map key:

```yaml title="atlas-schema.yaml"
apiVersion: db.atlasgo.io/v1alpha1
kind: AtlasSchema
metadata:
  name: myapp
spec:
  schema:
    configMapKeyRef:
      key: schema.sql
      name: mysql-schema
  # Skipping all other fields for brevity.
```

## Configuration for the `AtlasSchema` resource

The `AtlasSchema` resource is used to define the desired state of a target database.

Available fields:

#### `urlFrom`

The `urlFrom` field is used to load the URL of the target database from another resource such as a
Kubernetes secret.

```yaml
urlFrom:
    secretKeyRef:
      key: url
      name: mysql-credentials
```

### `url`

The `url` field is used to define the URL of the target database directly. This is not recommended, but may
be useful for testing purposes.

```yaml
url: "mysql://user:pass@localhost:3306/myapp"
```

### `schema`

The `schema` field is used to define the desired schema of the target database.

This can be defined in either plain SQL or in Atlas HCL.

```yaml
schema:
    sql: |
      create table users (
        id int not null auto_increment,
        name varchar(255) not null,
        email varchar(255) uniuse
      );
```

```yaml
schema:
  hcl: |
    schema "myapp" {
    }
    table "users" {
      column "id" {
        type = int
      }
      // ...
    }
```

Alternatively, you can reference a key in a `ConfigMap` to store the desired schema of your database:

```
schema:
  configMapKeyRef:
    key: schema.sql
    name: mysql-schema
```

Note: the `.sql` suffix on the key denotes that the schema is defined in plain SQL. If you are using Atlas HCL,
you should use the `.hcl` suffix instead.

### `policy`

The `policy` field is used to define policies that control how the operator will apply changes to the target database.

#### `lint`

The `lint` field is used to define policies that control how the operator will lint the desired schema.

```yaml
policy:
  lint:
    destructive:
      error: true
```

Currently, the only lint policy available is `destructive`. This policy controls what the operator will do if it
detects a destructive change such as dropping a column or table.

#### `diff`

The `diff` field is used to define the diff policies that are used to plan the schema changes.

```yaml
policy:
  diff:
   skip:
    drop_column: true
```

Currently, the only diff policy available is `skip`. This policy controls which kind of schema changes will be
skipped from the produced plan. The following options are available:
* `add_column`, `add_foreign_key`, `add_index`, `add_schema`, `add_table`, `drop_column`, `drop_foreign_key`,
  `drop_index`, `drop_schema`, `drop_table`, `modify_column`, `modify_foreign_key`, `modify_index`,
  `modify_schema`, `modify_table`

### `exclude`

The `exclude` field is used to define tables that should be excluded from being managed by the operator.
This is useful for resources that belong to other applications and are managed in other ways.

```yaml
exclude:
- external_table_managed_elsewhere
```

### `schemas`

The `schemas` field is used to define schemas that should be managed by the operator. This is used
to manage multiple schemas in a single database and works only if the connection string is database-bound.

```yaml
schemas:
- schema1
- schema2
```
---
title: Standalone Mode
slug: /portal/gorm/standalone
---

To use GORM with Atlas, we will use the [GORM Atlas Provider](https://github.com/ariga/atlas-provider-gorm)
to automatically plan schema migrations.

### Installation

1. Install Atlas from macOS or Linux by running:

```shell
curl -sSf https://atlasgo.sh | sh
```

See [atlasgo.io](https://atlasgo.io/getting-started#installation) for more installation options.

2. Install the provider by running:
```shell
go get -u ariga.io/atlas-provider-gorm
```

### Setup

If all of your GORM models exist in a single package, and either embed `gorm.Model` or contain `gorm` struct
tags, you can use the provider directly to load your GORM schema into Atlas.

1. In your project directory, create a new file named `atlas.hcl` with the following contents:

```hcl title=atlas.hcl
data "external_schema" "gorm" {
  program = [
    "go",
    "run",
    "-mod=mod",
    "ariga.io/atlas-provider-gorm",
    "load",
    "--path", "./path/to/models",
    "--dialect", "mysql", // | postgres | sqlite | sqlserver
  ]
}

env "gorm" {
  src = data.external_schema.gorm.url
  dev = "docker://mysql/8/dev"
  migration {
    dir = "file://migrations"
  }
  format {
    migrate {
      diff = "{{ sql . \"  \" }}"
    }
  }
}
```

2. To prevent the Go Modules system from dropping this dependency from our `go.mod` file, let's follow
the [official recommendation](https://github.com/golang/go/wiki/Modules#how-can-i-track-tool-dependencies-for-a-module)
for tracking dependencies of tools and add a file named tools.go with the following
contents:

```go title=tools.go
//go:build tools
package main

import _ "ariga.io/atlas-provider-gorm/gormschema"
```

Alternatively, you can simply add a blank import to the models.go file we created above.

3. Finally, to tidy things up, run:
```shell
go mod tidy
```

### Next Steps

Now that your project is set up, start by choosing between the two workflows offered by Atlas for generating and
planning migrations.
Select the one you prefer that works best for you:

* **Declarative Migrations**: Set up a Terraform-like workflow where each migration is calculated as the diff between
your desired state and the current state of the database.

* **Versioned Migrations**: Set up a migration directory for your project, creating a version-controlled source of truth
of your database schema.


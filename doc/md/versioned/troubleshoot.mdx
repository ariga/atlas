---
id: troubleshoot
slug: /versioned/troubleshoot
title: Migration Troubleshooting
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

There are cases, where the migration applying does not go through without an error. This document aims to provide
general support for troubleshooting migration failures.

## Retrieve Migration Status

Atlas provides the `atlas migrate status` command to retrieve information about the migration status of a database. You
can either use this command or have a look at the `atlas migrate apply` output to gather knowledge about the issue that
caused the migration failure. An example output can be seen below.

:::info

Note, that `atlas migrate status` does not show migration attempts, that got rolled back. As long as a migration failure
is wrapped with a transaction by a database with transactional DDL support, Atlas will rollback entries to the revision
table within the transaction.

:::

<Tabs
defaultValue="apply_stdout"
values={[
{label: 'atlas migrate apply (STDOUT)', value: 'apply_stdout'},
{label: 'atlas migrate apply (STDERR)', value: 'apply_stderr'},
{label: 'atlas migrate status', value: 'status'},
]}>
<TabItem value="apply_stdout">

```text
$ atlas --env local migrate apply 1 --tx-mode none
Migrating to version 2 from 1 (1 migrations in total):

  -- migrating version 2
    -> INSERT INTO `users` (`id`, `name`) VALUES (1, 'masseelch'), (2, 'rotemtam'), (3, 'a8m');
    -> INSERT INTO `groups` (`id`, `name`) VALUES (1, 'Founders'), (2, 'Senior Engineers'), (3, 'Junior Engineers');
    -> INSERT INTO `user_groups` (`user_id`, `group_id`) VALUES
    -- Founders
    (2, 1), (3, 1),
    -- Seniors
    (1, 2), (2, 2), (3, 2),
    -- Constraint error (adding masseelch twice to seniors)
    (1, 2);
// highlight-next-line-error-message
     Error 1062: Duplicate entry '1-2' for key 'user_groups.PRIMARY'

  -------------------------
  -- 2.521007ms
  -- 0 migrations ok (1 with errors)
  -- 2 sql statements ok (1 with errors)

// highlight-next-line-error-message
Error: Execution had errors:
// highlight-next-line-error-message
Error 1062: Duplicate entry '1-2' for key 'user_groups.PRIMARY'
```

</TabItem>
<TabItem value="apply_stderr">

```text
$ atlas --env local migrate apply 1 --tx-mode none
Error: sql/migrate: execute: executing statement "INSERT INTO `user_groups` (`user_id`, `group_id`) VALUES
    -- Founders\n    (2, 1), (3, 1),
    -- Seniors\n    (1, 2), (2, 2), (3, 2),
    -- Constraint error (adding masseelch twice to seniors)
    (1, 2);" from version "2": Error 1062: Duplicate entry '1-2' for key 'user_groups.PRIMARY'
```

</TabItem>
<TabItem value="status">

```text
$ atlas --env local migrate status
Migration Status: PENDING
  -- Current Version: 2 (2 statements applied)
  -- Next Version:    2 (1 statements left)
  -- Executed Files:  2 (last one partially)
  -- Pending Files:   2

Last migration attempt had errors:
  -- SQL:   INSERT INTO `user_groups` (`user_id`, `group_id`) VALUES     -- Founders     (2, 1), (3, 1),     -- Seniors     (1, 2), (2, 2), (3, 2),     -- Constraint error (adding masseelch twice to seniors)     (1, 2);
// highlight-next-line-error-message
  -- ERROR: Error 1062: Duplicate entry '1-2' for key 'user_groups.PRIMARY'
```

</TabItem>
</Tabs>

## Fixing Migration Failures

In our experience, the most common failures are introduced by one of the following issues:

- **Syntax Error**: One SQL statement contained a syntax error. Since Atlas provides a way to [lint](/versioned/lint) a
migration directory, this case happens due to a misconfiguration, e.g. not executing the linter before applying the
migration or applying against the wrong dialect (like SQLite files against MySQL).
- **DDL Semantics**: One SQL statement was semantically incorrect, e.g. adding a table that does already exist. This
case is usually caused by a schema drift, e.g. because someone manually manipulated the database schema.
- **Data Dependant Change**: One SQL statement contained a data dependant change. If your migration adds a constraint
like `NOT NULL` and the column does contain `NULL` values, the migration will throw an error. Though Atlas' linting
will warn if such a change is detected, this is still a possible scenario that could break migration execution.
- **Connection Loss**: For a number of reasons the connection to the database could be interrupted, e.g. due to a
network failure or database crash.

### Connection Loss Failures

Just re-try migration execution. Atlas is smart enough to figure out where to proceed execution. For very rare cases,
where when working without a transaction (or after an implicit commit) a connection loss occurs between an SQL statement
and the entry in Atlas schema history table, you might need to manually revert the last applied statement because in
those cases Atlas will continue applying one statement early.

### Syntax Errors

Fix the migration file and re-try migration execution. Atlas is smart enough to continue the execution starting with the
statement following the last successfully applied one.

### DDL Semantics

Creating or editing schema resources can result in migration failure, e.g. if you are trying to create a table that does
already exist or to modify a table that does not exist. The cause for this is either an incorrect migration file or a
schema drift, e.g. if someone dropped, created or modified a resource.

#### Option 1: Incorrect Migration File

Solution can be simple: fix the migration file and re-apply the migration. For cases with multiple deployments or no
(fast) editorial access to the migration file you have to fix the database state to match whatever the migration file is
expecting. You can either do this by hand or use one of the `atlas schema` commands. See
[Option 2](#option-2-schema-drift) for more information.

Once the migration / database is fixed, you can retry migration execution.

#### Option 2: Schema Drift

In case of a schema drift, we still consider the migration files the source of truth. Editing its contents to match the
managed database will most likely break other deployments or the local dev. The solution is to fix the database schema.
This can be done manually or with the help of `atlas schema apply` / `atlas schema diff` commands. Both commands know
how to read a database state from a migration directory and compare it with a state read from a database. The only
difference is, that `atlas schema apply` can then automatically apply the changes to the database, while
`atlas schema diff` will print the SQL on screen for you to check run by hand. You can utilize the `atlas schema status`
command to get information about the currently applied migration version.

##### atlas schema diff

<Tabs
defaultValue="dir"
values={[
{label: 'Migration Directory', value: 'dir'},
{label: 'HCL File', value: 'hcl'},
{label: 'Another Database', value: 'db'},
]}>
<TabItem value="dir">

Compare the state of the `from` database (the one with the schema drift), to the desired state given in the migration
directory. Note the query parameter `version` in the connection string to the migration directory, specifying the
version to consider the current state of the schema.

```shell
atlas schema diff \
  --from "driver://user:pass@host:port/db" \
  --to "file:///path/to/migrations/dir?format=atlas&version=myTargetVersion" \
  --dev-url "driver://user:pass@host:port/dev_db"
```

</TabItem>
<TabItem value="hcl">

Compare the state of the `from` database (the one with the schema drift), to the desired state given in one or more HCL
files.

```shell
atlas schema diff \
  --from "driver://user:pass@host:port/db" \
  --to "file:///path/to/schema_1.hcl" \
  --to "file:///path/to/schema_2.hcl" \
  --dev-url "driver://user:pass@host:port/dev_db"
```

</TabItem>
<TabItem value="db">

Compare the state of the `from` database (the one with the schema drift), to the desired state given by another database
(e.g. a local dev copy of the schema).

```shell
atlas schema diff \
  --from "driver://user:pass@host:port/current" \
  --to "driver://user:pass@host:port/desired"
```

</TabItem>
</Tabs>

Once you apply the SQL shown by `atlas migrate diff` onto your database, the schema drift should have vanished, and you
can retry migration applying.

#### atlas schema apply

Instead of only showing the SQL on the screen, you can immediately let Atlas apply it (Atlas will prompt for
confirmation first).

<Tabs
defaultValue="dir"
values={[
{label: 'Migration Directory', value: 'dir'},
{label: 'HCL File', value: 'hcl'},
{label: 'Another Database', value: 'db'},
]}>
<TabItem value="dir">

Migrate the state of the `url` database (the one with the schema drift), to the desired state given in the migration
directory. Note the query parameter `version` in the connection string to the migration directory, specifying the
version to consider the current state of the schema.

```shell
atlas schema apply \
  --url "driver://user:pass@host:port/db" \
  --to "file:///path/to/migrations/dir?format=atlas&version=myTargetVersion" \
  --dev-url "driver://user:pass@host:port/dev_db"
```

</TabItem>
<TabItem value="hcl">

Compare the state of the `url` database (the one with the schema drift), to the desired state given in one or more HCL
files.

```shell
atlas schema apply \
  --url "driver://user:pass@host:port/db" \
  --to "file:///path/to/schema_1.hcl" \
  --to "file:///path/to/schema_2.hcl" \
  --dev-url "driver://user:pass@host:port/dev_db"
```

</TabItem>
<TabItem value="db">

Compare the state of the `url` database (the one with the schema drift), to the desired state given by another database
(e.g. a local dev copy of the schema).

```shell
atlas schema diff \
  --from "driver://user:pass@host:port/current" \
  --to "driver://user:pass@host:port/desired"
```

</TabItem>
</Tabs>

### Data Dependant Failures

If the issue is caused by adding or changing a constraint, it may result in a migration failure if the existing data
is not valid for the new constraint. E.g. changing a column from formerly `int NULL` to `int NOT NULL` on a column that
contains `NULL` values will cause the migration to fail. This can be fixed by "fixing" the data and re-trying the
migration applying.

In any case, we advise to add the executed statements to fix the data to the migration file to not run into this issue
again for other deployments.

## A Word on Transactions

At Ariga, we advise to favor correctness over performance when it comes to database changes. Wrapping migration
execution in a transaction ensures the changes made to the database are rolled back if an error occurs along the way and
even in cases where the connection is lost, the changes are not committed. However, some databases (most notably
MySQL / MariaDB) do not support
[transactional DDL](https://wiki.postgresql.org/wiki/Transactional_DDL_in_PostgreSQL:_A_Competitive_Analysis). If
working with a database with no support for transactional DDL, a rollback will not restore the state previous to the
migration execution, and you end up with a "broken" database state. But since Atlas stores its own information about
applied statements within the same transaction, it will start execution with the next statement in the migration file
on a following migration attempt.

## Manipulating the Schema Revisions Table

Atlas stores information about applied migrations in the managed database. Sometimes, you want to tell Atlas that you
manually applied or rolled back a migration file. Atlas provides the
[`atlas migrate set`](/cli-reference#atlas-migrate-set) command for such cases.

:::warning

Please refrain from manually making changes to the Atlas revision table. The behavior of Atlas after such a change is
undefined, and it can possibly break your database to a point you cannot recover from.

:::

## Automatic Migration Fixing

Coming soon: `atlas migrate fix` to automatically resolve the most common sources of migration failures.

[//]: # (Atlas has its own migration execution engine, that works with the Atlas migration file format, e.g. migration files)

[//]: # (generated by [`atlas migrate diff`]&#40;/versioned/diff&#41;.)

[//]: # ()
[//]: # (### Arguments)

[//]: # (`atlas migrate apply` accepts one positional integer argument to specify how many pending migration files to run.)

[//]: # (* `atlas migrate apply` run all pending migrations)

[//]: # (* `atlas migrate apply 2` run at most 2 pending migrations)

[//]: # ()
[//]: # (### Flags)

[//]: # (When using `migrate apply` to apply migrations, users must supply multiple parameters:)

[//]: # (* `--url` the [URL]&#40;/concepts/url&#41; to the database to apply migrations on.)

[//]: # (* `--dir` the URL of the migration directory, by default it is `file://migrations`, e.g a)

[//]: # ( directory named `migrations` in the current working directory.)

[//]: # ()
[//]: # (### Schema Revision Information)

[//]: # ()
[//]: # (Atlas saves information about the applied migrations on a table called `atlas_schema_revisions` in the connected)

[//]: # (database schema &#40;e.g. `mysql://user@host/my_schema` or `postgres://user@host/db?search_path=my_schema`&#41;. If the database)

[//]: # (connection is not bound to a specific schema &#40;e.g. `mysql://user@host/` or `postgres://user@host/db`&#41;, the table is)

[//]: # (stored in its own schema called `atlas_schema_revisions`. This behavior can be changed by setting the schema manually:)

[//]: # (+ `--revisions-schema my_schema` to store the data in `my_schema.atlas_schema_revisions`.)

[//]: # ()
[//]: # (### Transaction Configuration)

[//]: # ()
[//]: # (By default, Atlas creates one transaction per migration file and will roll back that transaction if a statement in the)

[//]: # (wrapped migration fails to execute. Atlas supports three different transaction modes:)

[//]: # (* `--tx-mode file` &#40;default&#41; will wrap each pending migration into its own transaction.)

[//]: # (* `--tx-mode all` will wrap all pending migration files into one transaction.)

[//]: # (* `--tx-mode none` will not create any transaction. If a statement fails, the execution will stop. However, Atlas is)

[//]: # (smart enough to detect which statement fails and on another migration attempt will continue with the failed statement.)

[//]: # (This means altering the migration file from the failed statements onwards is safe and recommended.)

[//]: # ()
[//]: # (:::caution)

[//]: # (Please be aware, that non DDL transactional databases like)

[//]: # (MySQL &#40;due to [implicit commits]&#40;https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html&#41;&#41; can not be safely rolled)

[//]: # (back completely, and you might end up with a mismatched schema and revision table state. Atlas will handle those cases)

[//]: # (in future releases. A good source of information can be found in the)

[//]: # ([PostgreSQL wiki]&#40;https://wiki.postgresql.org/wiki/Transactional_DDL_in_PostgreSQL:_A_Competitive_Analysis&#41;.)

[//]: # (:::)

[//]: # ()
[//]: # (### Existing Databases)

[//]: # ()
[//]: # (If you have an existing database project and want to switch over to Atlas Versioned Migrations, you need to provide)

[//]: # (Atlas with a starting point. The first step is to create a migration file reflecting the current schema state. This can)

[//]: # (be easily done:)

[//]: # ()
[//]: # (```shell)

[//]: # (atlas migrate diff my_baseline \)

[//]: # (  --dir "file://migrations" \)

[//]: # (  --to "mysql://root:pass@remote:3306/my_schema")

[//]: # (```)

[//]: # ()
[//]: # (<Tabs)

[//]: # (defaultValue="baseline")

[//]: # (values={[)

[//]: # ({label: '1_baseline.sql', value: 'baseline'},)

[//]: # ({label: '2_add_pets_table.sql', value: 'first_version'},)

[//]: # (]}>)

[//]: # (<TabItem value="baseline">)

[//]: # ()
[//]: # (```sql)

[//]: # (CREATE TABLE `users` &#40;)

[//]: # (    `id` bigint&#40;20&#41; NOT NULL AUTO_INCREMENT,)

[//]: # (    `age` bigint&#40;20&#41; NOT NULL,)

[//]: # (    `name` varchar&#40;255&#41; COLLATE utf8mb4_bin NOT NULL,)

[//]: # (    PRIMARY KEY &#40;`id`&#41;,)

[//]: # (    UNIQUE KEY `age` &#40;`age`&#41;)

[//]: # (&#41;)

[//]: # (```)

[//]: # ()
[//]: # (</TabItem>)

[//]: # (<TabItem value="first_version">)

[//]: # ()
[//]: # (```sql)

[//]: # (CREATE TABLE `pets` &#40;)

[//]: # (    `id` bigint&#40;20&#41; NOT NULL AUTO_INCREMENT,)

[//]: # (    `name` varchar&#40;255&#41; COLLATE utf8mb4_bin NOT NULL,)

[//]: # (    PRIMARY KEY &#40;`id`&#41;)

[//]: # (&#41;)

[//]: # (```)

[//]: # ()
[//]: # (</TabItem>)

[//]: # (</Tabs>)

[//]: # ()
[//]: # (On your first migration execution attempt, you can then specify a baseline version. Atlas will mark this version as)

[//]: # (already applied and proceed with the next version:)

[//]: # (* `--baseline 1` will skip all files including version 1 &#40;`1_baseline.sql`&#41; and proceed with the next version)

[//]: # (&#40;`2_add_pets_table`&#41;.)

[//]: # ()
[//]: # (If your database does contain resources but no revision information yet, Atlas will refuse to execute migration files.)

[//]: # (One way to override that behavior is by using the `--baseline` flag above. However, e.g. in cases where the existing)

[//]: # (tables are not managed by Atlas at all and should not be part of a baseline file, you can run the initial migration)

[//]: # (attempt by providing the following flag:)

[//]: # (* `--allow-dirty` to allow starting migration execution on a non-clean database.)

[//]: # ()
[//]: # (`--allow-dirty` and `--baseline` are mutually exclusive.)

[//]: # ()
[//]: # (### Dry Run)

[//]: # ()
[//]: # (If you want to check what exactly Atlas would do when attempting a migration execution, you can provide the `--dry-run`)

[//]: # (flag:)

[//]: # (* `--dry-run` to not execute any SQL but print it on the screen.)

[//]: # ()
[//]: # (### Migration status)

[//]: # ()
[//]: # (In addition to the `--dry-run` flag Atlas also provides the `atlas migrate status` command, that provides in-depth)

[//]: # (information about the migration status of the connected database.)

[//]: # ()
[//]: # (### Examples)

[//]: # ()
[//]: # (First time apply with baseline on production environment:)

[//]: # (```shell)

[//]: # (atlas migrate apply \)

[//]: # (  --env "production" \)

[//]: # (  --baseline "20220811074144")

[//]: # (```)

[//]: # ()
[//]: # (Execute 1 pending migration file, but don't run, but print SQL statements on screen:)

[//]: # (```shell)

[//]: # (atlas migrate apply 1 \)

[//]: # (  --env "production" \)

[//]: # (  --baseline "20220811074144" \)

[//]: # (  --dry-run)

[//]: # (```)

[//]: # ()
[//]: # (Specify revision table schema and custom migration directory path:)

[//]: # (```shell)

[//]: # (atlas migrate apply \)

[//]: # (  --url "mysql://root:pass@remote:3306/my_database" \)

[//]: # (  --revisions-schema "atlas_migration_history" \)

[//]: # (  --dir "file://custom/path/to/dir")

[//]: # (```)

[//]: # ()
[//]: # (Ignore unclean database and run the first 3 migrations:)

[//]: # (```shell)

[//]: # (atlas migrate apply 3 \)

[//]: # (  --url "mysql://root:pass@remote:3306/my_database" \)

[//]: # (  --dir "file://custom/path/to/dir")

[//]: # (```)

[//]: # ()
[//]: # (Run all pending migrations, but do not use a transaction:)

[//]: # (```shell)

[//]: # (atlas migrate apply \)

[//]: # (  --url "mysql://root:pass@remote:3306/my_database" \)

[//]: # (  --tx-mode "none")

[//]: # (```)

[//]: # ()
[//]: # (Show information about the migration status of a deployment:)

[//]: # (```shell)

[//]: # (atlas migrate status \)

[//]: # (  --url "mysql://root:pass@remote:3306/my_database" \)

[//]: # (  --dir "file://custom/path/to/dir" \)

[//]: # (  --revisions-schema "atlas_migration_history")

[//]: # (```)

[//]: # ()
[//]: # (### Reference)

[//]: # ()
[//]: # ([CLI Command Reference]&#40;/cli-reference#atlas-migrate-apply&#41;)

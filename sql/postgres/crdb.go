// Copyright 2021-present The Atlas Authors. All rights reserved.
// This source code is licensed under the Apache 2.0 license found
// in the LICENSE file in the root directory of this source tree.

package postgres

import (
	"context"
	"database/sql"
	"fmt"
	"net/url"
	"regexp"
	"strings"

	"ariga.io/atlas/sql/internal/sqlx"
	"ariga.io/atlas/sql/migrate"
	"ariga.io/atlas/sql/schema"
	"ariga.io/atlas/sql/sqlclient"
)

// OpenCRDB opens a new CockroachDB driver.
func OpenCRDB(db schema.ExecQuerier) (migrate.Driver, error) {
	drv, err := open(db)
	if err != nil {
		return nil, err
	}
	c := drv.conn
	c.crdb = true
	return &Driver{
		conn:        c,
		Differ:      &sqlx.Diff{DiffDriver: &crdbDiff{diff{c}}},
		Inspector:   &inspect{c},
		PlanApplier: &planApply{c},
	}, nil
}

func init() {
	sqlclient.Register(
		"cockroach",
		sqlclient.DriverOpener(OpenCRDB),
		sqlclient.RegisterCodec(MarshalHCL, EvalHCL),
		sqlclient.RegisterFlavours("crdb"),
		sqlclient.RegisterURLParser(func(u *url.URL) *sqlclient.URL {
			return &sqlclient.URL{URL: u, DSN: u.String(), Schema: u.Query().Get("search_path")}
		}),
	)
}

// crdbDiff implements the sqlx.DiffDriver for CockroachDB.
type crdbDiff struct{ diff }

var _ sqlx.DiffDriver = (*crdbDiff)(nil)

// IndexAttrChanged reports if the index attributes were changed.
func (cd *crdbDiff) IndexAttrChanged(from, to []schema.Attr) bool {
	t1 := &IndexType{T: IndexTypeBTree}
	if sqlx.Has(from, t1) {
		t1.T = strings.ToUpper(t1.T)
	}
	t2 := &IndexType{T: IndexTypeBTree}
	if sqlx.Has(to, t2) {
		t2.T = strings.ToUpper(t2.T)
	}
	if t1.T != t2.T {
		return true
	}
	var p1, p2 IndexPredicate
	return sqlx.Has(from, &p1) != sqlx.Has(to, &p2) || (p1.P != p2.P && p1.P != sqlx.MayWrap(p2.P))
}

// Normalize implements the sqlx.Normalizer.
func (cd *crdbDiff) Normalize(from, to *schema.Table) {
	cd.normalize(from)
	cd.normalize(to)
	cd.diff.normalize(from)
	cd.diff.normalize(to)
}

func (cd *crdbDiff) normalize(table *schema.Table) {
	if table.PrimaryKey == nil {
		prim, ok := table.Column("rowid")
		if !ok {
			prim = schema.NewColumn("rowid").
				AddAttrs(Identity{}).
				SetType(&schema.IntegerType{})
			table.AddColumns(prim)
		}
		table.PrimaryKey = &schema.Index{
			Name:   "primary",
			Unique: true,
			Table:  table,
			Parts: []*schema.IndexPart{{
				SeqNo: 1,
				C:     prim,
			}},
		}
	}
	for _, c := range table.Columns {
		if id, ok := identity(c.Attrs); ok && c.Default == nil {
			c.Default = &schema.RawExpr{
				X: fmt.Sprintf("nextval('%s.%s_%s_seq'::REGCLASS)", table.Schema.Name, table.Name, c.Name),
			}
			id.Generation = "generated by default as identity"
			id.Sequence = &Sequence{Start: defaultSeqStart, Increment: defaultSeqIncrement}
			for j := 0; j < len(c.Attrs); j++ {
				switch c.Attrs[j].(type) {
				case *Identity:
					c.Attrs[j] = id
				}
			}
		}
		switch t := c.Type.Type.(type) {
		// Integer types are aliased.
		// see: cockroachlabs.com/docs/v21.2/int.html#names-and-aliases.
		case *schema.IntegerType:
			switch t.T {
			case TypeBigInt, TypeInteger, TypeInt8, TypeInt64, TypeInt:
				t.T = TypeBigInt
			case TypeInt2, TypeSmallInt:
				t.T = TypeSmallInt
			}
		case *schema.JSONType:
			switch t.T {
			// Type json is aliased to jsonb.
			case TypeJSON:
				t.T = TypeJSONB
			}
		}
	}
}

func (i *inspect) crdbIndexes(ctx context.Context, s *schema.Schema) error {
	rows, err := i.querySchema(ctx, crdbIndexesQuery, s)
	if err != nil {
		return fmt.Errorf("postgres: querying schema %q indexes: %w", s.Name, err)
	}
	defer rows.Close()
	if err := i.crdbAddIndexes(s, rows); err != nil {
		return err
	}
	return rows.Err()
}

var reIndexType = regexp.MustCompile("(?i)USING (BTREE|GIN|GIST)")

func (i *inspect) crdbAddIndexes(s *schema.Schema, rows *sql.Rows) error {
	// Unlike Postgres, Cockroach may have duplicate index names.
	names := make(map[string]*schema.Index)
	for rows.Next() {
		var (
			uniq, primary                        bool
			table, name, createStmt              string
			column, contype, pred, expr, comment sql.NullString
		)
		if err := rows.Scan(&table, &name, &column, &primary, &uniq, &contype, &createStmt, &pred, &expr, &comment); err != nil {
			return fmt.Errorf("cockroach: scanning indexes for schema %q: %w", s.Name, err)
		}
		t, ok := s.Table(table)
		if !ok {
			return fmt.Errorf("table %q was not found in schema", table)
		}
		uniqueName := fmt.Sprintf("%s.%s", table, name)
		idx, ok := names[uniqueName]
		if !ok {
			idx = &schema.Index{
				Name:   name,
				Unique: uniq,
				Table:  t,
			}
			// Extract index type information from index create statement.
			// See: https://www.cockroachlabs.com/docs/stable/create-index.html.
			if parts := reIndexType.FindStringSubmatch(createStmt); len(parts) > 0 {
				idx.Attrs = append(idx.Attrs, &IndexType{T: parts[1]})
			}
			if sqlx.ValidString(comment) {
				idx.Attrs = append(idx.Attrs, &schema.Comment{Text: comment.String})
			}
			if sqlx.ValidString(contype) {
				idx.Attrs = append(idx.Attrs, &ConType{T: contype.String})
			}
			if sqlx.ValidString(pred) {
				idx.Attrs = append(idx.Attrs, &IndexPredicate{P: pred.String})
			}
			names[uniqueName] = idx
			if primary {
				t.PrimaryKey = idx
			} else {
				t.Indexes = append(t.Indexes, idx)
			}
		}
		part := &schema.IndexPart{SeqNo: len(idx.Parts) + 1, Desc: strings.Contains(createStmt, "DESC")}
		switch {
		case sqlx.ValidString(column):
			part.C, ok = t.Column(column.String)
			if !ok {
				return fmt.Errorf("cockroach: column %q was not found for index %q", column.String, idx.Name)
			}
			part.C.Indexes = append(part.C.Indexes, idx)
		case sqlx.ValidString(expr):
			part.X = &schema.RawExpr{
				X: expr.String,
			}
		default:
			return fmt.Errorf("cockroach: invalid part for index %q", idx.Name)
		}
		idx.Parts = append(idx.Parts, part)
	}
	return nil
}

// CockroachDB types that are not part of PostgreSQL.
const (
	TypeInt64    = "int64"
	TypeGeometry = "geometry"
)

// CockroachDB query for getting schema indexes.
const crdbIndexesQuery = `
SELECT
	t.relname AS table_name,
	i.relname AS index_name,
	a.attname AS column_name,
	idx.indisprimary AS primary,
	idx.indisunique AS unique,
	c.contype AS constraint_type,
	pgi.indexdef create_stmt,
	pg_get_expr(idx.indpred, idx.indrelid) AS predicate,
	pg_get_indexdef(idx.indexrelid, idx.ord, false) AS expression,
	pg_catalog.obj_description(i.oid, 'pg_class') AS comment
	FROM
	(
		select
			*,
			generate_series(1,array_length(i.indkey,1)) as ord,
			unnest(i.indkey) AS key
		from pg_index i
	) idx
	JOIN pg_class i ON i.oid = idx.indexrelid
	JOIN pg_class t ON t.oid = idx.indrelid
	JOIN pg_namespace n ON n.oid = t.relnamespace
	LEFT JOIN pg_constraint c ON idx.indexrelid = c.conindid
	LEFT JOIN pg_indexes pgi ON pgi.tablename = t.relname AND indexname = i.relname
	LEFT JOIN pg_attribute a ON (a.attrelid, a.attnum) = (idx.indrelid, idx.key)
WHERE
	n.nspname = $1
	AND t.relname IN (%s)
	AND COALESCE(c.contype, '') <> 'f'
ORDER BY
	table_name, index_name, idx.ord
`

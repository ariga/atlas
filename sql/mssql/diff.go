// Copyright 2021-present The Atlas Authors. All rights reserved.
// This source code is licensed under the Apache 2.0 license found
// in the LICENSE file in the root directory of this source tree.

package mssql

import (
	"context"
	"fmt"
	"reflect"
	"strings"

	"ariga.io/atlas/sql/internal/sqlx"
	"ariga.io/atlas/sql/schema"
)

// DefaultDiff provides basic diffing capabilities for MS-SQL dialects.
// Note, it is recommended to call Open, create a new Driver and use its Differ
// when a database connection is available.
var DefaultDiff schema.Differ = &sqlx.Diff{DiffDriver: &diff{}}

// A diff provides a MS-SQL implementation for sqlx.DiffDriver.
type diff struct{ conn }

// noChange describes a zero change.
var noChange struct{ schema.Change }

// SchemaAttrDiff returns a changeset for migrating schema attributes from one state to the other.
func (d *diff) SchemaAttrDiff(_, _ *schema.Schema) []schema.Change {
	// No special schema attribute diffing for MS-SQL.
	return nil
}

// TableAttrDiff returns a changeset for migrating table attributes from one state to the other.
func (d *diff) TableAttrDiff(from, to *schema.Table) ([]schema.Change, error) {
	var changes []schema.Change
	if change := sqlx.CommentDiff(from.Attrs, to.Attrs); change != nil {
		changes = append(changes, change)
	}
	return append(changes, sqlx.CheckDiff(from, to)...), nil
}

// ColumnChange returns the schema changes (if any) for migrating one column to the other.
func (d *diff) ColumnChange(t *schema.Table, from, to *schema.Column) (schema.ChangeKind, error) {
	var (
		change  = sqlx.CommentChange(from.Attrs, to.Attrs)
		changed bool
		err     error
	)
	if from.Type.Null != to.Type.Null {
		change |= schema.ChangeNull
	}
	if changed, err = typeChanged(from, to); err != nil {
		return schema.NoChange, err
	}
	if changed {
		change |= schema.ChangeType
	}
	if changed, err = d.defaultChanged(from, to); err != nil {
		return schema.NoChange, err
	}
	if changed {
		change |= schema.ChangeDefault
	}
	if identityChanged(from.Attrs, to.Attrs) {
		change |= schema.ChangeAttr
	}
	if changed, err = computedChanged(from, to); err != nil {
		return schema.NoChange, err
	}
	if changed {
		change |= schema.ChangeGenerated
	}
	if columnCollationChanged(from.Attrs, to.Attrs, t.Schema.Realm) {
		change |= schema.ChangeCollate
	}
	return change, nil
}

// IsGeneratedIndexName reports if the index name was generated by the database.
func (d *diff) IsGeneratedIndexName(t *schema.Table, i *schema.Index) bool {
	// MS-SQL generates index names for primary keys.
	return fmt.Sprintf("PK_%s", t.Name) == i.Name
}

// IndexAttrChanged reports if the index attributes were changed.
// The default type is CLUSTERED if no type was specified.
func (*diff) IndexAttrChanged(from, to []schema.Attr) bool {
	t1, t2 := indexType(from), indexType(to)
	if t1.T != t2.T {
		return true
	}
	var p1, p2 IndexPredicate
	if sqlx.Has(from, &p1) != sqlx.Has(to, &p2) || (p1.P != p2.P && p1.P != sqlx.MayWrap(p2.P)) {
		return true
	}
	if indexIncludeChanged(from, to) {
		return true
	}
	return false
}

// IndexPartAttrChanged reports if the index-part attributes were changed.
func (*diff) IndexPartAttrChanged(_, _ *schema.Index, _ int) bool {
	return false
}

// ReferenceChanged reports if the foreign key referential action was changed.
func (*diff) ReferenceChanged(from, to schema.ReferenceOption) bool {
	// According to MS-SQL, the NO ACTION rule is set
	// if no referential action was defined in foreign key.
	if from == "" {
		from = schema.NoAction
	}
	if to == "" {
		to = schema.NoAction
	}
	return from != to
}

// columnCollationChanged indicates if there is a change to the column collation.
func columnCollationChanged(from, to []schema.Attr, r *schema.Realm) bool {
	var top []schema.Attr
	if r != nil {
		top = r.Attrs
	}
	var (
		fromC, topC, toC       schema.Collation
		fromHas, topHas, toHas = sqlx.Has(from, &fromC), sqlx.Has(top, &topC), sqlx.Has(to, &toC)
	)
	// Column was updated with custom COLLATE that was dropped.
	// Hence, we should revert to the one defined on the top.
	return fromHas && !toHas && topHas && fromC.V != topC.V ||
		// Custom COLLATE was added to the column. Hence,
		// Does not match the one defined in the top.
		!fromHas && toHas && topHas && toC.V != topC.V ||
		// COLLATE was explicitly changed.
		fromHas && toHas && fromC.V != toC.V
}

func typeChanged(from, to *schema.Column) (bool, error) {
	fromT, toT := from.Type.Type, to.Type.Type
	if fromT == nil || toT == nil {
		return false, fmt.Errorf("mssql: missing type information for column %q", from.Name)
	}
	if reflect.TypeOf(fromT) != reflect.TypeOf(toT) {
		return true, nil
	}
	var changed bool
	switch fromT := fromT.(type) {
	case *schema.BinaryType, *schema.DecimalType, *schema.FloatType, *schema.IntegerType,
		*schema.SpatialType, *schema.StringType, *schema.TimeType:
		t1, err := FormatType(toT)
		if err != nil {
			return false, err
		}
		t2, err := FormatType(fromT)
		if err != nil {
			return false, err
		}
		changed = t1 != t2
	case *BitType:
		toT := toT.(*BitType)
		changed = fromT.T != toT.T
	case *HierarchyIDType:
		toT := toT.(*HierarchyIDType)
		changed = fromT.T != toT.T
	case *MoneyType:
		toT := toT.(*MoneyType)
		changed = fromT.T != toT.T
	case *UniqueIdentifierType:
		toT := toT.(*UniqueIdentifierType)
		changed = fromT.T != toT.T
	case *UserDefinedType:
		toT := toT.(*UserDefinedType)
		changed = fromT.T != toT.T
	case *XMLType:
		toT := toT.(*XMLType)
		changed = fromT.T != toT.T
	default:
		return false, &sqlx.UnsupportedTypeError{Type: fromT}
	}
	return changed, nil
}

// defaultChanged reports if the default value of a column was changed.
func (d *diff) defaultChanged(from, to *schema.Column) (bool, error) {
	d1, ok1 := sqlx.DefaultValue(from)
	d2, ok2 := sqlx.DefaultValue(to)
	if ok1 != ok2 {
		return true, nil
	}
	if !ok1 && !ok2 || d1 == d2 {
		return false, nil
	}
	var (
		_, fromX = from.Default.(*schema.RawExpr)
		_, toX   = to.Default.(*schema.RawExpr)
	)
	// In case one of the DEFAULT values is an expression, and a database connection is
	// available (not DefaultDiff), we use the database to compare in case of mismatch.
	if (fromX || toX) && d.conn.ExecQuerier != nil {
		equals, err := d.defaultEqual(from.Default, to.Default)
		return !equals, err
	}
	return true, nil
}

// defaultEqual reports if the DEFAULT values x and y
// equal according to the database engine.
func (d *diff) defaultEqual(from, to schema.Expr) (bool, error) {
	var d1, d2 string
	switch from := from.(type) {
	case *schema.Literal:
		d1 = from.V
	case *schema.RawExpr:
		d1 = from.X
	}
	switch to := to.(type) {
	case *schema.Literal:
		d2 = to.V
	case *schema.RawExpr:
		d2 = to.X
	}
	// The DEFAULT expressions are safe to be inlined in the SELECT
	// statement same as we inline them in the CREATE TABLE statement.
	rows, err := d.QueryContext(context.Background(),
		fmt.Sprintf("SELECT CASE WHEN %s = %s THEN 1 ELSE 0 END", d1, d2))
	if err != nil {
		return false, err
	}
	var b bool
	if err := sqlx.ScanOne(rows, &b); err != nil {
		return false, err
	}
	return b, nil
}

// indexType returns the index type from its attribute.
// The default type is NONCLUSTERED if no type was specified.
//
// https://learn.microsoft.com/en-us/sql/t-sql/statements/create-index-transact-sql#nonclustered
func indexType(attr []schema.Attr) *IndexType {
	t := &IndexType{T: IndexTypeNonClustered}
	if sqlx.Has(attr, t) {
		t.T = strings.ToUpper(t.T)
	}
	return t
}

// indexIncludeChanged reports if the INCLUDE attribute clause was changed.
func indexIncludeChanged(from, to []schema.Attr) bool {
	var fromI, toI IndexInclude
	if sqlx.Has(from, &fromI) != sqlx.Has(to, &toI) || len(fromI.Columns) != len(toI.Columns) {
		return true
	}
	for i := range fromI.Columns {
		if fromI.Columns[i].Name != toI.Columns[i].Name {
			return true
		}
	}
	return false
}

// computedChanged reports if the computed expression of a column was changed.
func computedChanged(from, to *schema.Column) (bool, error) {
	var fromX, toX schema.GeneratedExpr
	switch fromHas, toHas := sqlx.Has(from.Attrs, &fromX), sqlx.Has(to.Attrs, &toX); {
	case fromHas && toHas && sqlx.MayWrap(fromX.Expr) != sqlx.MayWrap(toX.Expr):
		return false, fmt.Errorf("changing the computed expression for a column %q is not supported", from.Name)
	case !fromHas && toHas:
		return false, fmt.Errorf("changing column %q to computed column is not supported (drop and add is required)", from.Name)
	case fromHas && !toHas:
		// SQL Server does not allow to change a computed column to a regular column.
		// It is required to drop and add the column, select the computed value
		// and insert it into the new column.
		return false, fmt.Errorf("changing computed column %q to regular column is not supported (drop and add is required)", from.Name)
	default:
		return false, nil
	}
}

// Default IDENTITY attributes.
const (
	defaultSeed      = 1
	defaultIncrement = 1
)

// identityChanged reports if one of the identity attributes was changed.
func identityChanged(from, to []schema.Attr) bool {
	i1, ok1 := identity(from)
	i2, ok2 := identity(to)
	if !ok1 && !ok2 || ok1 != ok2 {
		return ok1 != ok2
	}
	return i1.Seed != i2.Seed || i1.Increment != i2.Increment
}

func identity(attrs []schema.Attr) (*Identity, bool) {
	i := &Identity{}
	if !sqlx.Has(attrs, i) {
		return nil, false
	}
	if i.Seed == 0 {
		i.Seed = defaultSeed
	}
	if i.Increment == 0 {
		i.Increment = defaultIncrement
	}
	return i, true
}

func quote(s string) string {
	if sqlx.IsQuoted(s, '\'') {
		return s
	}
	return "'" + strings.ReplaceAll(s, "'", "''") + "'"
}

// Copyright 2021-present The Atlas Authors. All rights reserved.
// This source code is licensed under the Apache 2.0 license found
// in the LICENSE file in the root directory of this source tree.

package mysql

import (
	"encoding/hex"
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"ariga.io/atlas/sql/internal/sqlx"
	"ariga.io/atlas/sql/schema"
)

// A diff provides a MySQL implementation for sqlx.DiffDriver.
type diff struct{ conn }

// SchemaAttrDiff returns a changeset for migrating schema attributes from one state to the other.
func (d *diff) SchemaAttrDiff(from, to *schema.Schema) []schema.Change {
	var (
		topAttr []schema.Attr
		changes []schema.Change
	)
	if from.Realm != nil {
		topAttr = from.Realm.Attrs
	}
	// Charset change.
	if change := d.charsetChange(from.Attrs, topAttr, to.Attrs); change != noChange {
		changes = append(changes, change)
	}
	// Collation change.
	if change := d.collationChange(from.Attrs, topAttr, to.Attrs); change != noChange {
		changes = append(changes, change)
	}
	return changes
}

// TableAttrDiff returns a changeset for migrating table attributes from one state to the other.
func (d *diff) TableAttrDiff(from, to *schema.Table) ([]schema.Change, error) {
	var changes []schema.Change
	if change := d.autoIncChange(from.Attrs, to.Attrs); change != noChange {
		changes = append(changes, change)
	}
	if change := sqlx.CommentDiff(from.Attrs, to.Attrs); change != nil {
		changes = append(changes, change)
	}
	if change := d.charsetChange(from.Attrs, from.Schema.Attrs, to.Attrs); change != noChange {
		changes = append(changes, change)
	}
	if change := d.collationChange(from.Attrs, from.Schema.Attrs, to.Attrs); change != noChange {
		changes = append(changes, change)
	}
	if _, ok := d.supportsCheck(); !ok && sqlx.Has(to.Attrs, &schema.Check{}) {
		return nil, fmt.Errorf("version %q does not support CHECK constraints", d.version)
	}
	// For MariaDB, we skip JSON CHECK constraints that were created by the databases,
	// or by Atlas for older versions. These CHECK constraints (inlined on the columns)
	// also cannot be dropped using "DROP CONSTRAINTS", but can be modified and dropped
	// using "MODIFY COLUMN".
	var checks []schema.Change
	for _, c := range sqlx.CheckDiff(from, to, func(c1, c2 *schema.Check) bool {
		return enforced(c1.Attrs) == enforced(c2.Attrs)
	}) {
		drop, ok := c.(*schema.DropCheck)
		if !ok || !strings.HasPrefix(drop.C.Expr, "json_valid") {
			checks = append(checks, c)
			continue
		}
		// Generated CHECK have the form of "json_valid(`<column>`)"
		// and named as the column.
		if _, ok := to.Column(drop.C.Name); !ok {
			checks = append(checks, c)
		}
	}
	return append(changes, checks...), nil
}

// ColumnChange returns the schema changes (if any) for migrating one column to the other.
func (d *diff) ColumnChange(fromT *schema.Table, from, to *schema.Column) (schema.ChangeKind, error) {
	change := sqlx.CommentChange(from.Attrs, to.Attrs)
	if from.Type.Null != to.Type.Null {
		change |= schema.ChangeNull
	}
	changed, err := d.typeChanged(from, to)
	if err != nil {
		return schema.NoChange, err
	}
	if changed {
		change |= schema.ChangeType
	}
	if changed, err = d.defaultChanged(from, to); err != nil {
		return schema.NoChange, err
	}
	if changed {
		change |= schema.ChangeDefault
	}
	if changed, err = d.generatedChanged(from, to); err != nil {
		return schema.NoChange, err
	}
	if changed {
		change |= schema.ChangeGenerated
	}
	if changed, err = d.columnCharsetChanged(fromT, from, to); err != nil {
		return schema.NoChange, err
	}
	if changed {
		change |= schema.ChangeCharset
	}
	if changed, err = d.columnCollateChanged(fromT, from, to); err != nil {
		return schema.NoChange, err
	}
	if changed {
		change |= schema.ChangeCollate
	}
	return change, nil
}

// IsGeneratedIndexName reports if the index name was generated by the database.
func (d *diff) IsGeneratedIndexName(_ *schema.Table, idx *schema.Index) bool {
	// Auto-generated index names for functional/expression indexes. See.
	// mysql-server/sql/sql_table.cc#add_functional_index_to_create_list
	const f = "functional_index"
	switch {
	case d.supportsIndexExpr() && idx.Name == f:
		return true
	case d.supportsIndexExpr() && strings.HasPrefix(idx.Name+"_", f):
		i, err := strconv.ParseInt(strings.TrimLeft(idx.Name, idx.Name+"_"), 10, 64)
		return err == nil && i > 1
	case len(idx.Parts) == 0 || idx.Parts[0].C == nil:
		return false
	}
	// Unnamed INDEX or UNIQUE constraints are named by
	// the first index-part (as column or part of it).
	// For example, "c", "c_2", "c_3", etc.
	switch name := idx.Parts[0].C.Name; {
	case idx.Name == name:
		return true
	case strings.HasPrefix(idx.Name, name+"_"):
		i, err := strconv.ParseInt(strings.TrimPrefix(idx.Name, name+"_"), 10, 64)
		return err == nil && i > 1
	default:
		return false
	}
}

// IndexAttrChanged reports if the index attributes were changed.
func (*diff) IndexAttrChanged(from, to []schema.Attr) bool {
	return indexType(from).T != indexType(to).T
}

// IndexPartAttrChanged reports if the index-part attributes (collation or prefix) were changed.
func (*diff) IndexPartAttrChanged(from, to *schema.IndexPart) bool {
	var s1, s2 SubPart
	return sqlx.Has(from.Attrs, &s1) != sqlx.Has(to.Attrs, &s2) || s1.Len != s2.Len
}

// ReferenceChanged reports if the foreign key referential action was changed.
func (*diff) ReferenceChanged(from, to schema.ReferenceOption) bool {
	// According to MySQL docs, foreign key constraints are checked
	// immediately, so NO ACTION is the same as RESTRICT. Specifying
	// RESTRICT (or NO ACTION) is the same as omitting the ON DELETE
	// or ON UPDATE clause.
	if from == "" || from == schema.Restrict {
		from = schema.NoAction
	}
	if to == "" || to == schema.Restrict {
		to = schema.NoAction
	}
	return from != to
}

// Normalize implements the sqlx.Normalizer interface.
func (*diff) Normalize(from, to *schema.Table) error {
	indexes := make([]*schema.Index, 0, len(from.Indexes))
	for _, idx := range from.Indexes {
		// MySQL requires that foreign key columns be indexed; Therefore, if the child
		// table is defined on non-indexed columns, an index is automatically created
		// to satisfy the constraint.
		// Therefore, if no such key was defined on the desired state, the diff will
		// recommend dropping it on migration. Therefore, we fix it by dropping it from
		// the current state manually.
		if _, ok := to.Index(idx.Name); ok || !keySupportsFK(from, idx) {
			indexes = append(indexes, idx)
		}
	}
	from.Indexes = indexes

	// Avoid proposing changes to the table COLLATE or CHARSET
	// in case only one of these properties is defined.
	if err := defaultCollate(&to.Attrs); err != nil {
		return err
	}
	return defaultCharset(&to.Attrs)
}

// collationChange returns the schema change for migrating the collation if
// it was changed, and it is not the default attribute inherited from its parent.
func (*diff) collationChange(from, top, to []schema.Attr) schema.Change {
	var fromC, topC, toC schema.Collation
	switch fromHas, topHas, toHas := sqlx.Has(from, &fromC), sqlx.Has(top, &topC), sqlx.Has(to, &toC); {
	case !fromHas && !toHas:
	case !fromHas:
		return &schema.AddAttr{
			A: &toC,
		}
	case !toHas:
		// There is no way to DROP a COLLATE that was configured on the table,
		// and it is not the default. Therefore, we use ModifyAttr and give it
		// the inherited (and default) collation from schema or server.
		if topHas && fromC.V != topC.V {
			return &schema.ModifyAttr{
				From: &fromC,
				To:   &topC,
			}
		}
	case fromC.V != toC.V:
		return &schema.ModifyAttr{
			From: &fromC,
			To:   &toC,
		}
	}
	return noChange
}

// charsetChange returns the schema change for migrating the collation if
// it was changed, and it is not the default attribute inherited from its parent.
func (*diff) charsetChange(from, top, to []schema.Attr) schema.Change {
	var fromC, topC, toC schema.Charset
	switch fromHas, topHas, toHas := sqlx.Has(from, &fromC), sqlx.Has(top, &topC), sqlx.Has(to, &toC); {
	case !fromHas && !toHas:
	case !fromHas:
		return &schema.AddAttr{
			A: &toC,
		}
	case !toHas:
		// There is no way to DROP a CHARSET that was configured on the table,
		// and it is not the default. Therefore, we use ModifyAttr and give it
		// the inherited (and default) collation from schema or server.
		if topHas && fromC.V != topC.V {
			return &schema.ModifyAttr{
				From: &fromC,
				To:   &topC,
			}
		}
	case fromC.V != toC.V:
		return &schema.ModifyAttr{
			From: &fromC,
			To:   &toC,
		}
	}
	return noChange
}

// columnCharsetChange indicates if there is a change to the column charset.
func (*diff) columnCharsetChanged(fromT *schema.Table, from, to *schema.Column) (bool, error) {
	if err := defaultCharset(&to.Attrs); err != nil {
		return false, err
	}
	var (
		fromC, topC, toC       schema.Charset
		fromHas, topHas, toHas = sqlx.Has(from.Attrs, &fromC), sqlx.Has(fromT.Attrs, &topC), sqlx.Has(to.Attrs, &toC)
	)
	// Column was updated with custom CHARSET that was dropped.
	// Hence, we should revert to the one defined on the table.
	return fromHas && !toHas && topHas && fromC.V != topC.V ||
		// Custom CHARSET was added to the column. Hence,
		// Does not match the one defined in the table.
		!fromHas && toHas && topHas && toC.V != topC.V ||
		// CHARSET was explicitly changed.
		fromHas && toHas && fromC.V != toC.V, nil

}

// columnCollateChanged indicates if there is a change to the column charset.
func (*diff) columnCollateChanged(fromT *schema.Table, from, to *schema.Column) (bool, error) {
	if err := defaultCollate(&to.Attrs); err != nil {
		return false, err
	}
	var (
		fromC, topC, toC       schema.Collation
		fromHas, topHas, toHas = sqlx.Has(from.Attrs, &fromC), sqlx.Has(fromT.Attrs, &topC), sqlx.Has(to.Attrs, &toC)
	)
	// Column was updated with custom COLLATE that was dropped.
	// Hence, we should revert to the one defined on the table.
	return fromHas && !toHas && topHas && fromC.V != topC.V ||
		// Custom COLLATE was added to the column. Hence,
		// Does not match the one defined in the table.
		!fromHas && toHas && topHas && toC.V != topC.V ||
		// COLLATE was explicitly changed.
		fromHas && toHas && fromC.V != toC.V, nil

}

// autoIncChange returns the schema change for changing the AUTO_INCREMENT
// attribute in case it is not the default.
func (*diff) autoIncChange(from, to []schema.Attr) schema.Change {
	var fromA, toA AutoIncrement
	switch fromHas, toHas := sqlx.Has(from, &fromA), sqlx.Has(to, &toA); {
	// Ignore if the AUTO_INCREMENT attribute was dropped from the desired schema.
	case fromHas && !toHas:
	// The AUTO_INCREMENT exists in the desired schema, and may not exist in the inspected one.
	// This can happen because older versions of MySQL (< 8.0) stored the AUTO_INCREMENT counter
	// in main memory (not persistent), and the value is reset on process restart for empty tables.
	case toA.V > 1 && toA.V > fromA.V:
		// Suggest a diff only if the desired value is greater than the inspected one,
		// because this attribute cannot be maintained in users schema and used to set
		// up only the initial value.
		return &schema.ModifyAttr{
			From: &fromA,
			To:   &toA,
		}
	}
	return noChange
}

// indexType returns the index type from its attribute.
// The default type is BTREE if no type was specified.
func indexType(attr []schema.Attr) *IndexType {
	t := &IndexType{T: IndexTypeBTree}
	if sqlx.Has(attr, t) {
		t.T = strings.ToUpper(t.T)
	}
	return t
}

// enforced returns the ENFORCED attribute for the CHECK
// constraint. A CHECK is ENFORCED if not state otherwise.
func enforced(attr []schema.Attr) bool {
	if e := (Enforced{}); sqlx.Has(attr, &e) {
		return e.V
	}
	return true
}

// noChange describes a zero change.
var noChange struct{ schema.Change }

func (d *diff) typeChanged(from, to *schema.Column) (bool, error) {
	fromT, toT := from.Type.Type, to.Type.Type
	if fromT == nil || toT == nil {
		return false, fmt.Errorf("mysql: missing type information for column %q", from.Name)
	}
	if reflect.TypeOf(fromT) != reflect.TypeOf(toT) {
		return true, nil
	}
	var changed bool
	switch fromT := fromT.(type) {
	case *schema.BinaryType, *schema.BoolType, *schema.DecimalType, *schema.FloatType:
		changed = mustFormat(fromT) != mustFormat(toT)
	case *schema.EnumType:
		toT := toT.(*schema.EnumType)
		changed = !sqlx.ValuesEqual(fromT.Values, toT.Values)
	case *schema.IntegerType:
		toT := toT.(*schema.IntegerType)
		// MySQL v8.0.19 dropped both display-width
		// and zerofill from the information schema.
		if d.supportsDisplayWidth() {
			ft, _, _, err := parseColumn(fromT.T)
			if err != nil {
				return false, err
			}
			tt, _, _, err := parseColumn(toT.T)
			if err != nil {
				return false, err
			}
			fromT.T, toT.T = ft[0], tt[0]
		}
		changed = fromT.T != toT.T || fromT.Unsigned != toT.Unsigned
	case *schema.JSONType:
		toT := toT.(*schema.JSONType)
		changed = fromT.T != toT.T
	case *schema.StringType:
		changed = mustFormat(fromT) != mustFormat(toT)
	case *schema.SpatialType:
		toT := toT.(*schema.SpatialType)
		changed = fromT.T != toT.T
	case *schema.TimeType:
		toT := toT.(*schema.TimeType)
		changed = fromT.T != toT.T
	case *BitType:
		toT := toT.(*BitType)
		changed = fromT.T != toT.T
	case *SetType:
		toT := toT.(*SetType)
		changed = !sqlx.ValuesEqual(fromT.Values, toT.Values)
	default:
		return false, &sqlx.UnsupportedTypeError{Type: fromT}
	}
	return changed, nil
}

// defaultChanged reports if the default value of a column was changed.
func (d *diff) defaultChanged(from, to *schema.Column) (bool, error) {
	d1, ok1 := sqlx.DefaultValue(from)
	d2, ok2 := sqlx.DefaultValue(to)
	if ok1 != ok2 {
		return true, nil
	}
	if d1 == d2 {
		return false, nil
	}
	switch from.Type.Type.(type) {
	case *schema.BinaryType:
		a, err1 := binValue(d1)
		b, err2 := binValue(d2)
		if err1 != nil || err2 != nil {
			return true, nil
		}
		return !equalsStringValues(a, b), nil
	case *schema.BoolType:
		a, err1 := boolValue(d1)
		b, err2 := boolValue(d2)
		if err1 == nil && err2 == nil {
			return a != b, nil
		}
		return false, nil
	case *schema.IntegerType:
		return !d.equalIntValues(d1, d2), nil
	case *schema.FloatType, *schema.DecimalType:
		return !d.equalFloatValues(d1, d2), nil
	case *schema.EnumType, *SetType, *schema.StringType:
		return !equalsStringValues(d1, d2), nil
	case *schema.TimeType:
		x1 := strings.ToLower(strings.Trim(d1, "' ()"))
		x2 := strings.ToLower(strings.Trim(d2, "' ()"))
		return x1 != x2, nil
	default:
		x1 := strings.Trim(d1, "'")
		x2 := strings.Trim(d2, "'")
		return x1 != x2, nil
	}
}

// generatedChanged reports if the generated expression of a column was changed.
func (*diff) generatedChanged(from, to *schema.Column) (bool, error) {
	var (
		fromX, toX     schema.GeneratedExpr
		fromHas, toHas = sqlx.Has(from.Attrs, &fromX), sqlx.Has(to.Attrs, &toX)
	)
	if !fromHas && !toHas || fromHas && toHas && sqlx.MayWrap(fromX.Expr) == sqlx.MayWrap(toX.Expr) && storedOrVirtual(fromX.Type) == storedOrVirtual(toX.Type) {
		return false, nil
	}
	return true, checkChangeGenerated(from, to)
}

// equalIntValues report if the 2 int default values are ~equal.
// Note that default expression are not supported atm.
func (d *diff) equalIntValues(x1, x2 string) bool {
	x1 = strings.ToLower(strings.Trim(x1, "' "))
	x2 = strings.ToLower(strings.Trim(x2, "' "))
	if x1 == x2 {
		return true
	}
	d1, err := strconv.ParseInt(x1, 10, 64)
	if err != nil {
		// Numbers are rounded down to their nearest integer.
		f, err := strconv.ParseFloat(x1, 64)
		if err != nil {
			return false
		}
		d1 = int64(f)
	}
	d2, err := strconv.ParseInt(x2, 10, 64)
	if err != nil {
		// Numbers are rounded down to their nearest integer.
		f, err := strconv.ParseFloat(x2, 64)
		if err != nil {
			return false
		}
		d2 = int64(f)
	}
	return d1 == d2
}

// equalFloatValues report if the 2 float default values are ~equal.
// Note that default expression are not supported atm.
func (d *diff) equalFloatValues(x1, x2 string) bool {
	x1 = strings.ToLower(strings.Trim(x1, "' "))
	x2 = strings.ToLower(strings.Trim(x2, "' "))
	if x1 == x2 {
		return true
	}
	d1, err := strconv.ParseFloat(x1, 64)
	if err != nil {
		return false
	}
	d2, err := strconv.ParseFloat(x2, 64)
	if err != nil {
		return false
	}
	return d1 == d2
}

// equalsStringValues report if the 2 string default values are
// equal after dropping their quotes.
func equalsStringValues(x1, x2 string) bool {
	a, err1 := sqlx.Unquote(x1)
	b, err2 := sqlx.Unquote(x2)
	return a == b && err1 == nil && err2 == nil
}

// boolValue returns the MySQL boolean value from the given string (if it is known).
func boolValue(x string) (bool, error) {
	switch x {
	case "1", "'1'", "TRUE", "true":
		return true, nil
	case "0", "'0'", "FALSE", "false":
		return false, nil
	default:
		return false, fmt.Errorf("mysql: unknown value: %q", x)
	}
}

// binValue returns the MySQL binary value from the given string (if it is known).
func binValue(x string) (string, error) {
	if !isHex(x) {
		return x, nil
	}
	d, err := hex.DecodeString(x[2:])
	if err != nil {
		return x, err
	}
	return string(d), nil
}

// keySupportsFK reports if the index key was created automatically by MySQL
// to support the constraint. See sql/sql_table.cc#find_fk_supporting_key.
func keySupportsFK(t *schema.Table, idx *schema.Index) bool {
	if _, ok := t.ForeignKey(idx.Name); ok {
		return true
	}
search:
	for _, fk := range t.ForeignKeys {
		if len(fk.Columns) != len(idx.Parts) {
			continue
		}
		for i, c := range fk.Columns {
			if idx.Parts[i].C == nil || idx.Parts[i].C.Name != c.Name {
				continue search
			}
		}
		return true
	}
	return false
}

// defaultCollate appends the default COLLATE to the attributes in case a
// custom character-set was defined for the element and the COLLATE was not.
func defaultCollate(attrs *[]schema.Attr) error {
	var (
		charset  schema.Charset
		defaults = map[string]string{
			"armscii8": "armscii8_general_ci",
			"ascii":    "ascii_general_ci",
			"big5":     "big5_chinese_ci",
			"binary":   "binary",
			"cp1250":   "cp1250_general_ci",
			"cp1251":   "cp1251_general_ci",
			"cp1256":   "cp1256_general_ci",
			"cp1257":   "cp1257_general_ci",
			"cp850":    "cp850_general_ci",
			"cp852":    "cp852_general_ci",
			"cp866":    "cp866_general_ci",
			"cp932":    "cp932_japanese_ci",
			"dec8":     "dec8_swedish_ci",
			"eucjpms":  "eucjpms_japanese_ci",
			"euckr":    "euckr_korean_ci",
			"gb18030":  "gb18030_chinese_ci",
			"gb2312":   "gb2312_chinese_ci",
			"gbk":      "gbk_chinese_ci",
			"geostd8":  "geostd8_general_ci",
			"greek":    "greek_general_ci",
			"hebrew":   "hebrew_general_ci",
			"hp8":      "hp8_english_ci",
			"keybcs2":  "keybcs2_general_ci",
			"koi8r":    "koi8r_general_ci",
			"koi8u":    "koi8u_general_ci",
			"latin1":   "latin1_swedish_ci",
			"latin2":   "latin2_general_ci",
			"latin5":   "latin5_turkish_ci",
			"latin7":   "latin7_general_ci",
			"macce":    "macce_general_ci",
			"macroman": "macroman_general_ci",
			"sjis":     "sjis_japanese_ci",
			"swe7":     "swe7_swedish_ci",
			"tis620":   "tis620_thai_ci",
			"ucs2":     "ucs2_general_ci",
			"ujis":     "ujis_japanese_ci",
			"utf16":    "utf16_general_ci",
			"utf16le":  "utf16le_general_ci",
			"utf32":    "utf32_general_ci",
			"utf8":     "utf8_general_ci",
			"utf8mb3":  "utf8_general_ci",
			"utf8mb4":  "utf8mb4_0900_ai_ci",
		}
	)
	if !sqlx.Has(*attrs, &charset) || sqlx.Has(*attrs, &schema.Collation{}) {
		return nil
	}
	v, ok := defaults[charset.V]
	if !ok {
		return fmt.Errorf("mysql: unknown character set: %q", charset.V)
	}
	schema.ReplaceOrAppend(attrs, &schema.Collation{V: v})
	return nil
}

// defaultCharset appends the default CHARSET to the attributes in case a
// custom collation was defined for the element and the CHARSET was not.
func defaultCharset(attrs *[]schema.Attr) error {
	var (
		collate  schema.Collation
		defaults = map[string]string{
			"armscii8_bin":               "armscii",
			"armscii8_general_ci":        "armscii",
			"ascii_bin":                  "ascii",
			"ascii_general_ci":           "ascii",
			"big5_bin":                   "big5",
			"big5_chinese_ci":            "big5",
			"binary":                     "binary",
			"cp1250_bin":                 "cp1250",
			"cp1250_croatian_ci":         "cp1250",
			"cp1250_czech_cs":            "cp1250",
			"cp1250_general_ci":          "cp1250",
			"cp1250_polish_ci":           "cp1250",
			"cp1251_bin":                 "cp1251",
			"cp1251_bulgarian_ci":        "cp1251",
			"cp1251_general_ci":          "cp1251",
			"cp1251_general_cs":          "cp1251",
			"cp1251_ukrainian_ci":        "cp1251",
			"cp1256_bin":                 "cp1256",
			"cp1256_general_ci":          "cp1256",
			"cp1257_bin":                 "cp1257",
			"cp1257_general_ci":          "cp1257",
			"cp1257_lithuanian_ci":       "cp1257",
			"cp850_bin":                  "cp850",
			"cp850_general_ci":           "cp850",
			"cp852_bin":                  "cp852",
			"cp852_general_ci":           "cp852",
			"cp866_bin":                  "cp866",
			"cp866_general_ci":           "cp866",
			"cp932_bin":                  "cp932",
			"cp932_japanese_ci":          "cp932",
			"dec8_bin":                   "dec8",
			"dec8_swedish_ci":            "dec8",
			"eucjpms_bin":                "eucjpms",
			"eucjpms_japanese_ci":        "eucjpms",
			"euckr_bin":                  "euckr",
			"euckr_korean_ci":            "euckr",
			"gb18030_bin":                "gb18030",
			"gb18030_chinese_ci":         "gb18030",
			"gb18030_unicode_520_ci":     "gb18030",
			"gb2312_bin":                 "gb2312",
			"gb2312_chinese_ci":          "gb2312",
			"gbk_bin":                    "gbk",
			"gbk_chinese_ci":             "gbk",
			"geostd8_bin":                "geostd8",
			"geostd8_general_ci":         "geostd8",
			"greek_bin":                  "greek",
			"greek_general_ci":           "greek",
			"hebrew_bin":                 "hebrew",
			"hebrew_general_ci":          "hebrew",
			"hp8_bin":                    "hp8",
			"hp8_english_ci":             "hp8",
			"keybcs2_bin":                "keybcs2",
			"keybcs2_general_ci":         "keybcs2",
			"koi8r_bin":                  "koi8r",
			"koi8r_general_ci":           "koi8r",
			"koi8u_bin":                  "koi8u",
			"koi8u_general_ci":           "koi8u",
			"latin1_bin":                 "latin1",
			"latin1_danish_ci":           "latin1",
			"latin1_general_ci":          "latin1",
			"latin1_general_cs":          "latin1",
			"latin1_german1_ci":          "latin1",
			"latin1_german2_ci":          "latin1",
			"latin1_spanish_ci":          "latin1",
			"latin1_swedish_ci":          "latin1",
			"latin2_bin":                 "latin2",
			"latin2_croatian_ci":         "latin2",
			"latin2_czech_cs":            "latin2",
			"latin2_general_ci":          "latin2",
			"latin2_hungarian_ci":        "latin2",
			"latin5_bin":                 "latin5",
			"latin5_turkish_ci":          "latin5",
			"latin7_bin":                 "latin7",
			"latin7_estonian_cs":         "latin7",
			"latin7_general_ci":          "latin7",
			"latin7_general_cs":          "latin7",
			"macce_bin":                  "macce",
			"macce_general_ci":           "macce",
			"macroman_bin":               "macroma",
			"macroman_general_ci":        "macroma",
			"sjis_bin":                   "sjis",
			"sjis_japanese_ci":           "sjis",
			"swe7_bin":                   "swe7",
			"swe7_swedish_ci":            "swe7",
			"tis620_bin":                 "tis620",
			"tis620_thai_ci":             "tis620",
			"ucs2_bin":                   "ucs2",
			"ucs2_croatian_ci":           "ucs2",
			"ucs2_czech_ci":              "ucs2",
			"ucs2_danish_ci":             "ucs2",
			"ucs2_esperanto_ci":          "ucs2",
			"ucs2_estonian_ci":           "ucs2",
			"ucs2_general_ci":            "ucs2",
			"ucs2_general_mysql500_ci":   "ucs2",
			"ucs2_german2_ci":            "ucs2",
			"ucs2_hungarian_ci":          "ucs2",
			"ucs2_icelandic_ci":          "ucs2",
			"ucs2_latvian_ci":            "ucs2",
			"ucs2_lithuanian_ci":         "ucs2",
			"ucs2_persian_ci":            "ucs2",
			"ucs2_polish_ci":             "ucs2",
			"ucs2_romanian_ci":           "ucs2",
			"ucs2_roman_ci":              "ucs2",
			"ucs2_sinhala_ci":            "ucs2",
			"ucs2_slovak_ci":             "ucs2",
			"ucs2_slovenian_ci":          "ucs2",
			"ucs2_spanish2_ci":           "ucs2",
			"ucs2_spanish_ci":            "ucs2",
			"ucs2_swedish_ci":            "ucs2",
			"ucs2_turkish_ci":            "ucs2",
			"ucs2_unicode_520_ci":        "ucs2",
			"ucs2_unicode_ci":            "ucs2",
			"ucs2_vietnamese_ci":         "ucs2",
			"ujis_bin":                   "ujis",
			"ujis_japanese_ci":           "ujis",
			"utf16le_bin":                "utf16le",
			"utf16le_general_ci":         "utf16le",
			"utf16_bin":                  "utf16",
			"utf16_croatian_ci":          "utf16",
			"utf16_czech_ci":             "utf16",
			"utf16_danish_ci":            "utf16",
			"utf16_esperanto_ci":         "utf16",
			"utf16_estonian_ci":          "utf16",
			"utf16_general_ci":           "utf16",
			"utf16_german2_ci":           "utf16",
			"utf16_hungarian_ci":         "utf16",
			"utf16_icelandic_ci":         "utf16",
			"utf16_latvian_ci":           "utf16",
			"utf16_lithuanian_ci":        "utf16",
			"utf16_persian_ci":           "utf16",
			"utf16_polish_ci":            "utf16",
			"utf16_romanian_ci":          "utf16",
			"utf16_roman_ci":             "utf16",
			"utf16_sinhala_ci":           "utf16",
			"utf16_slovak_ci":            "utf16",
			"utf16_slovenian_ci":         "utf16",
			"utf16_spanish2_ci":          "utf16",
			"utf16_spanish_ci":           "utf16",
			"utf16_swedish_ci":           "utf16",
			"utf16_turkish_ci":           "utf16",
			"utf16_unicode_520_ci":       "utf16",
			"utf16_unicode_ci":           "utf16",
			"utf16_vietnamese_ci":        "utf16",
			"utf32_bin":                  "utf32",
			"utf32_croatian_ci":          "utf32",
			"utf32_czech_ci":             "utf32",
			"utf32_danish_ci":            "utf32",
			"utf32_esperanto_ci":         "utf32",
			"utf32_estonian_ci":          "utf32",
			"utf32_general_ci":           "utf32",
			"utf32_german2_ci":           "utf32",
			"utf32_hungarian_ci":         "utf32",
			"utf32_icelandic_ci":         "utf32",
			"utf32_latvian_ci":           "utf32",
			"utf32_lithuanian_ci":        "utf32",
			"utf32_persian_ci":           "utf32",
			"utf32_polish_ci":            "utf32",
			"utf32_romanian_ci":          "utf32",
			"utf32_roman_ci":             "utf32",
			"utf32_sinhala_ci":           "utf32",
			"utf32_slovak_ci":            "utf32",
			"utf32_slovenian_ci":         "utf32",
			"utf32_spanish2_ci":          "utf32",
			"utf32_spanish_ci":           "utf32",
			"utf32_swedish_ci":           "utf32",
			"utf32_turkish_ci":           "utf32",
			"utf32_unicode_520_ci":       "utf32",
			"utf32_unicode_ci":           "utf32",
			"utf32_vietnamese_ci":        "utf32",
			"utf8mb4_0900_ai_ci":         "utf8mb4",
			"utf8mb4_0900_as_ci":         "utf8mb4",
			"utf8mb4_0900_as_cs":         "utf8mb4",
			"utf8mb4_0900_bin":           "utf8mb4",
			"utf8mb4_bin":                "utf8mb4",
			"utf8mb4_croatian_ci":        "utf8mb4",
			"utf8mb4_cs_0900_ai_ci":      "utf8mb4",
			"utf8mb4_cs_0900_as_cs":      "utf8mb4",
			"utf8mb4_czech_ci":           "utf8mb4",
			"utf8mb4_danish_ci":          "utf8mb4",
			"utf8mb4_da_0900_ai_ci":      "utf8mb4",
			"utf8mb4_da_0900_as_cs":      "utf8mb4",
			"utf8mb4_de_pb_0900_ai_ci":   "utf8mb4",
			"utf8mb4_de_pb_0900_as_cs":   "utf8mb4",
			"utf8mb4_eo_0900_ai_ci":      "utf8mb4",
			"utf8mb4_eo_0900_as_cs":      "utf8mb4",
			"utf8mb4_esperanto_ci":       "utf8mb4",
			"utf8mb4_estonian_ci":        "utf8mb4",
			"utf8mb4_es_0900_ai_ci":      "utf8mb4",
			"utf8mb4_es_0900_as_cs":      "utf8mb4",
			"utf8mb4_es_trad_0900_ai_ci": "utf8mb4",
			"utf8mb4_es_trad_0900_as_cs": "utf8mb4",
			"utf8mb4_et_0900_ai_ci":      "utf8mb4",
			"utf8mb4_et_0900_as_cs":      "utf8mb4",
			"utf8mb4_general_ci":         "utf8mb4",
			"utf8mb4_german2_ci":         "utf8mb4",
			"utf8mb4_hr_0900_ai_ci":      "utf8mb4",
			"utf8mb4_hr_0900_as_cs":      "utf8mb4",
			"utf8mb4_hungarian_ci":       "utf8mb4",
			"utf8mb4_hu_0900_ai_ci":      "utf8mb4",
			"utf8mb4_hu_0900_as_cs":      "utf8mb4",
			"utf8mb4_icelandic_ci":       "utf8mb4",
			"utf8mb4_is_0900_ai_ci":      "utf8mb4",
			"utf8mb4_is_0900_as_cs":      "utf8mb4",
			"utf8mb4_ja_0900_as_cs":      "utf8mb4",
			"utf8mb4_ja_0900_as_cs_ks":   "utf8mb4",
			"utf8mb4_latvian_ci":         "utf8mb4",
			"utf8mb4_la_0900_ai_ci":      "utf8mb4",
			"utf8mb4_la_0900_as_cs":      "utf8mb4",
			"utf8mb4_lithuanian_ci":      "utf8mb4",
			"utf8mb4_lt_0900_ai_ci":      "utf8mb4",
			"utf8mb4_lt_0900_as_cs":      "utf8mb4",
			"utf8mb4_lv_0900_ai_ci":      "utf8mb4",
			"utf8mb4_lv_0900_as_cs":      "utf8mb4",
			"utf8mb4_persian_ci":         "utf8mb4",
			"utf8mb4_pl_0900_ai_ci":      "utf8mb4",
			"utf8mb4_pl_0900_as_cs":      "utf8mb4",
			"utf8mb4_polish_ci":          "utf8mb4",
			"utf8mb4_romanian_ci":        "utf8mb4",
			"utf8mb4_roman_ci":           "utf8mb4",
			"utf8mb4_ro_0900_ai_ci":      "utf8mb4",
			"utf8mb4_ro_0900_as_cs":      "utf8mb4",
			"utf8mb4_ru_0900_ai_ci":      "utf8mb4",
			"utf8mb4_ru_0900_as_cs":      "utf8mb4",
			"utf8mb4_sinhala_ci":         "utf8mb4",
			"utf8mb4_sk_0900_ai_ci":      "utf8mb4",
			"utf8mb4_sk_0900_as_cs":      "utf8mb4",
			"utf8mb4_slovak_ci":          "utf8mb4",
			"utf8mb4_slovenian_ci":       "utf8mb4",
			"utf8mb4_sl_0900_ai_ci":      "utf8mb4",
			"utf8mb4_sl_0900_as_cs":      "utf8mb4",
			"utf8mb4_spanish2_ci":        "utf8mb4",
			"utf8mb4_spanish_ci":         "utf8mb4",
			"utf8mb4_sv_0900_ai_ci":      "utf8mb4",
			"utf8mb4_sv_0900_as_cs":      "utf8mb4",
			"utf8mb4_swedish_ci":         "utf8mb4",
			"utf8mb4_tr_0900_ai_ci":      "utf8mb4",
			"utf8mb4_tr_0900_as_cs":      "utf8mb4",
			"utf8mb4_turkish_ci":         "utf8mb4",
			"utf8mb4_unicode_520_ci":     "utf8mb4",
			"utf8mb4_unicode_ci":         "utf8mb4",
			"utf8mb4_vietnamese_ci":      "utf8mb4",
			"utf8mb4_vi_0900_ai_ci":      "utf8mb4",
			"utf8mb4_vi_0900_as_cs":      "utf8mb4",
			"utf8mb4_zh_0900_as_cs":      "utf8mb4",
			"utf8_bin":                   "utf8mb3",
			"utf8_croatian_ci":           "utf8mb3",
			"utf8_czech_ci":              "utf8mb3",
			"utf8_danish_ci":             "utf8mb3",
			"utf8_esperanto_ci":          "utf8mb3",
			"utf8_estonian_ci":           "utf8mb3",
			"utf8_general_ci":            "utf8mb3",
			"utf8_general_mysql500_ci":   "utf8mb3",
			"utf8_german2_ci":            "utf8mb3",
			"utf8_hungarian_ci":          "utf8mb3",
			"utf8_icelandic_ci":          "utf8mb3",
			"utf8_latvian_ci":            "utf8mb3",
			"utf8_lithuanian_ci":         "utf8mb3",
			"utf8_persian_ci":            "utf8mb3",
			"utf8_polish_ci":             "utf8mb3",
			"utf8_romanian_ci":           "utf8mb3",
			"utf8_roman_ci":              "utf8mb3",
			"utf8_sinhala_ci":            "utf8mb3",
			"utf8_slovak_ci":             "utf8mb3",
			"utf8_slovenian_ci":          "utf8mb3",
			"utf8_spanish2_ci":           "utf8mb3",
			"utf8_spanish_ci":            "utf8mb3",
			"utf8_swedish_ci":            "utf8mb3",
			"utf8_tolower_ci":            "utf8mb3",
			"utf8_turkish_ci":            "utf8mb3",
			"utf8_unicode_520_ci":        "utf8mb3",
			"utf8_unicode_ci":            "utf8mb3",
			"utf8_vietnamese_ci":         "utf8mb3",
		}
	)
	if !sqlx.Has(*attrs, &collate) || sqlx.Has(*attrs, &schema.Charset{}) {
		return nil
	}
	v, ok := defaults[collate.V]
	if !ok {
		return fmt.Errorf("mysql: unknown collation: %q", collate.V)
	}
	schema.ReplaceOrAppend(attrs, &schema.Charset{V: v})
	return nil
}
